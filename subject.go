package main

import (
	"sync"
)

type (
	Observer[T any] interface {
		OnNext(obj T)
	}

	Subject[T any] interface {
		Attach(observer Observer[T])
		Detach(observer Observer[T])
		Next(obj T)
	}

	subject[T any] struct {
		observers sync.Map
	}
)

func (s *subject[T]) Attach(observer Observer[T]) {
	s.observers.Store(observer, struct{}{})
}

func (s *subject[T]) Detach(observer Observer[T]) {
	s.observers.Delete(observer)
}

func (s *subject[T]) Next(obj T) {
	s.observers.Range(func(key, value any) bool {
		if observer, ok := key.(Observer[T]); ok {
			observer.OnNext(obj)
		}
		return true
	})
}

type (
	ImageSubject interface {
		Subject[string]
	}

	imageSubject struct {
		subject[string]
	}
)

func NewImageSubject() ImageSubject {
	return &imageSubject{}
}

type ResourceEventHandlerAdapter[T, K any] struct {
	Subject   Subject[K]
	AdaptFunc func(obj T) <-chan K
}

func (a *ResourceEventHandlerAdapter[T, K]) OnAdd(obj interface{}) {
	a.handleObj(obj)
}
func (a *ResourceEventHandlerAdapter[T, K]) OnUpdate(oldObj, newObj interface{}) {
	a.handleObj(newObj)
}
func (a *ResourceEventHandlerAdapter[T, K]) OnDelete(obj interface{}) {}

func (a *ResourceEventHandlerAdapter[T, K]) handleObj(obj any) {
	if realObj, ok := obj.(T); ok {
		for v := range a.AdaptFunc(realObj) {
			a.Subject.Next(v)
		}
	}
}
