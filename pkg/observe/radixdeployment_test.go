package observe

import (
	"context"
	"encoding/json"
	"testing"

	"github.com/equinor/radix-operator/pkg/apis/defaults"
	v1 "github.com/equinor/radix-operator/pkg/apis/radix/v1"
	"github.com/equinor/radix-vulnerability-scanner/pkg/dockercfg"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kubefake "k8s.io/client-go/kubernetes/fake"
)

func Test_RadixDeploymentContainerImageMapperWithDockerAuthSecret(t *testing.T) {
	namespace := "anynamespace"
	var receivedImages []ImageInfo
	fakeObserver := fakeImageInfoObserver{OnReceive: func(receivedObj ImageInfo) { receivedImages = append(receivedImages, receivedObj) }}
	kubeClient := kubefake.NewSimpleClientset()
	dockerConfig := dockercfg.Config{Auths: dockercfg.AuthMap{"docker.io": {}}}
	dockerAuthBytes, _ := json.Marshal(&dockerConfig)
	_, err := kubeClient.CoreV1().Secrets(namespace).Create(context.Background(), &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{Name: defaults.PrivateImageHubSecretName},
		Data: map[string][]byte{
			corev1.DockerConfigJsonKey: dockerAuthBytes,
		},
	}, metav1.CreateOptions{})
	require.NoError(t, err)

	sut := &RadixDeploymentContainerImageMapper{KubeClient: kubeClient}
	sut.AttachObserver(&fakeObserver)
	sut.Receive(&v1.RadixDeployment{
		ObjectMeta: metav1.ObjectMeta{Namespace: namespace},
		Spec: v1.RadixDeploymentSpec{
			Components: []v1.RadixDeployComponent{{Image: "c1"}, {Image: "c2"}},
			Jobs:       []v1.RadixDeployJobComponent{{Image: "j1"}, {Image: "j2"}},
		}})

	assert.ElementsMatch(t,
		[]ImageInfo{
			{ImageName: "c1", Platform: "linux/amd64", DockerConfig: dockerConfig},
			{ImageName: "c2", Platform: "linux/amd64", DockerConfig: dockerConfig},
			{ImageName: "j1", Platform: "linux/amd64", DockerConfig: dockerConfig},
			{ImageName: "j2", Platform: "linux/amd64", DockerConfig: dockerConfig},
		},
		receivedImages)
}

func Test_RadixDeploymentContainerImageMapperWithoutDockerAuthSecret(t *testing.T) {
	namespace := "anynamespace"
	var receivedImages []ImageInfo
	fakeObserver := fakeImageInfoObserver{OnReceive: func(receivedObj ImageInfo) { receivedImages = append(receivedImages, receivedObj) }}
	kubeClient := kubefake.NewSimpleClientset()
	sut := &RadixDeploymentContainerImageMapper{KubeClient: kubeClient}
	sut.AttachObserver(&fakeObserver)
	sut.Receive(&v1.RadixDeployment{
		ObjectMeta: metav1.ObjectMeta{Namespace: namespace},
		Spec: v1.RadixDeploymentSpec{
			Components: []v1.RadixDeployComponent{{Image: "c1"}, {Image: "c2"}},
			Jobs:       []v1.RadixDeployJobComponent{{Image: "j1"}, {Image: "j2"}},
		}})
	assert.ElementsMatch(t, []ImageInfo{
		{ImageName: "c1", Platform: "linux/amd64"},
		{ImageName: "c2", Platform: "linux/amd64"},
		{ImageName: "j1", Platform: "linux/amd64"},
		{ImageName: "j2", Platform: "linux/amd64"},
	}, receivedImages)
}

func Test_RadixDeploymentContainerImageMapperWithRuntime(t *testing.T) {
	namespace := "anynamespace"
	var receivedImages []ImageInfo
	fakeObserver := fakeImageInfoObserver{OnReceive: func(receivedObj ImageInfo) { receivedImages = append(receivedImages, receivedObj) }}
	kubeClient := kubefake.NewSimpleClientset()
	sut := &RadixDeploymentContainerImageMapper{KubeClient: kubeClient}
	sut.AttachObserver(&fakeObserver)
	sut.Receive(&v1.RadixDeployment{
		ObjectMeta: metav1.ObjectMeta{Namespace: namespace},
		Spec: v1.RadixDeploymentSpec{
			Components: []v1.RadixDeployComponent{{Image: "c1"}, {Image: "c2", Runtime: &v1.Runtime{Architecture: "otherarch"}}},
			Jobs:       []v1.RadixDeployJobComponent{{Image: "j1"}, {Image: "j2", Runtime: &v1.Runtime{Architecture: "otherarch"}}},
		}})
	assert.ElementsMatch(t, []ImageInfo{
		{ImageName: "c1", Platform: "linux/amd64"},
		{ImageName: "c2", Platform: "linux/otherarch"},
		{ImageName: "j1", Platform: "linux/amd64"},
		{ImageName: "j2", Platform: "linux/otherarch"},
	}, receivedImages)
}

func Test_RadixDeploymentListMapper(t *testing.T) {
	var receivedRds []*v1.RadixDeployment
	fakeObserver := fakeRadixDeploymentObserver{OnReceive: func(receivedObj *v1.RadixDeployment) { receivedRds = append(receivedRds, receivedObj) }}
	sut := &RadixDeploymentListMapper{}
	sut.AttachObserver(&fakeObserver)
	rd1 := &v1.RadixDeployment{Spec: v1.RadixDeploymentSpec{AppName: "app1"}}
	rd2 := &v1.RadixDeployment{Spec: v1.RadixDeploymentSpec{AppName: "app2"}}
	sut.Receive([]*v1.RadixDeployment{rd1, rd2})
	assert.ElementsMatch(t, []*v1.RadixDeployment{rd1, rd2}, receivedRds)
}
