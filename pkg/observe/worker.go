package observe

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/equinor/radix-vulnerability-scanner/pkg/handler"
	logger "github.com/sirupsen/logrus"
	"k8s.io/client-go/util/workqueue"
)

var _ Observer[string] = &ImageWorker{}

type (
	ImageWorker struct {
		queue   workqueue.RateLimitingInterface
		handler handler.Handler[string]
		running bool
		lock    sync.Mutex
	}
)

func NewImageWorker(handler handler.Handler[string]) *ImageWorker {
	return &ImageWorker{
		queue:   workqueue.NewRateLimitingQueue(workqueue.NewItemFastSlowRateLimiter(30*time.Second, 10*time.Minute, 2)),
		handler: handler,
	}
}

func (w *ImageWorker) Receive(obj string) {
	logger.Infof("enqueuing image %v", obj)
	w.queue.Add(obj)
}

func (w *ImageWorker) Start(workers uint, stop <-chan struct{}) error {
	w.lock.Lock()
	defer w.lock.Unlock()
	if w.running {
		return errors.New("image processor already running")
	}

	w.running = true
	go func() {
		<-stop
		w.running = false
	}()

	for i := uint(0); i < workers; i++ {
		go func(id uint) {
			w.worker(id, stop)
		}(i)
	}

	return nil
}

func (w *ImageWorker) worker(id uint, stop <-chan struct{}) {
	ctx, cancel := contextForChannel(stop)
	defer cancel()

	for !w.processNextItem(ctx) {
	}
}

func (w *ImageWorker) processNextItem(ctx context.Context) (shutdown bool) {
	item, shutdown := w.queue.Get()
	if shutdown {
		return
	}
	defer w.queue.Done(item)
	logger.Infof("processing image %v", item)

	if err := w.handler.Handle(ctx, fmt.Sprint(item)); err != nil {
		logger.Errorf("error processing %v: %v", item, err)
	}

	w.queue.Forget(item)
	return
}

func contextForChannel(parentCh <-chan struct{}) (context.Context, context.CancelFunc) {
	ctx, cancel := context.WithCancel(context.Background())

	go func() {
		select {
		case <-parentCh:
			cancel()
		case <-ctx.Done():
		}
	}()
	return ctx, cancel
}
