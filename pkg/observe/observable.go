package observe

import (
	"sync"
)

type (
	// Observable defines a type that can emit values to an Observer
	Observable[T any] interface {
		// AttachObserver registers an Observer that will receive values emitted by the Observable
		AttachObserver(observer Observer[T])
		// AttachObserver un-registers an Observer from the Observable to stop it from receiving values
		DetachObserver(observer Observer[T])
	}

	observable[T any] struct {
		observers sync.Map
	}
)

func (o *observable[T]) AttachObserver(observer Observer[T]) {
	o.observers.Store(observer, struct{}{})
}

func (o *observable[T]) DetachObserver(observer Observer[T]) {
	o.observers.Delete(observer)
}

func (o *observable[T]) notifyObservers(obj T) {
	o.observers.Range(func(key, value any) bool {
		if observer, ok := key.(Observer[T]); ok {
			observer.Receive(obj)
		}
		return true
	})
}
