package observe

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/equinor/radix-operator/pkg/apis/defaults"
	v1 "github.com/equinor/radix-operator/pkg/apis/radix/v1"
	"github.com/equinor/radix-operator/pkg/apis/utils"
	"github.com/equinor/radix-vulnerability-scanner/pkg/dockercfg"
	"github.com/rs/zerolog/log"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
)

type (
	// ImageInfo is sent to observers of RadixDeploymentContainerImageMapper
	ImageInfo struct {
		ImageName    string
		Platform     string
		DockerConfig dockercfg.Config
	}

	// RadixDeploymentContainerImageMapper receives RadixDeployments and emits images defined in jobs and componenets
	// together with docker auths data to any observers
	RadixDeploymentContainerImageMapper struct {
		KubeClient kubernetes.Interface
		observable[ImageInfo]
	}

	// RadixDeploymentListMapper receives slices of RadixDeployments and emits each RadixDeployments to any observers
	RadixDeploymentListMapper struct {
		observable[*v1.RadixDeployment]
	}
)

func (m *RadixDeploymentContainerImageMapper) Receive(rd *v1.RadixDeployment) {
	if rd == nil {
		return
	}

	dockerConfig, err := m.readDockerConfigJSON(rd.Namespace)
	if err != nil {
		log.Warn().Err(err).Msg("unable to read dockerconfigjson secret")
	}

	for _, c := range rd.Spec.Components {
		m.notifyObservers(m.buildImageInfo(&c, dockerConfig))
	}

	for _, c := range rd.Spec.Jobs {
		m.notifyObservers(m.buildImageInfo(&c, dockerConfig))
	}
}

func (m *RadixDeploymentContainerImageMapper) readDockerConfigJSON(namespace string) (dockercfg.Config, error) {
	var cfg = dockercfg.Config{}
	secret, err := m.KubeClient.CoreV1().Secrets(namespace).Get(context.Background(), defaults.PrivateImageHubSecretName, metav1.GetOptions{})
	if err != nil {
		return cfg, err
	}

	configJSON, ok := secret.Data[corev1.DockerConfigJsonKey]
	if !ok {
		return cfg, fmt.Errorf("secret %s in namespace %s does not contain data for %s", defaults.PrivateImageHubSecretName, namespace, corev1.DockerConfigJsonKey)
	}

	err = json.Unmarshal(configJSON, &cfg)
	if err != nil {
		return cfg, err
	}

	return cfg, nil
}
func (m *RadixDeploymentContainerImageMapper) buildImageInfo(c v1.RadixCommonDeployComponent, dockerCfg dockercfg.Config) ImageInfo {
	return ImageInfo{
		ImageName:    c.GetImage(),
		Platform:     m.parsePlatformForComponent(c),
		DockerConfig: dockerCfg,
	}
}
func (*RadixDeploymentContainerImageMapper) parsePlatformForComponent(c v1.RadixCommonDeployComponent) string {
	architecture := utils.GetArchitectureFromRuntime(c.GetRuntime())
	if len(architecture) == 0 {
		return ""
	}
	return fmt.Sprintf("linux/%s", architecture)
}

func (m *RadixDeploymentListMapper) Receive(rds []*v1.RadixDeployment) {
	for _, rd := range rds {
		m.notifyObservers(rd)
	}
}
