package dockercfg

import (
	"context"
	"encoding/json"
	"errors"
	"os"

	"github.com/containerd/containerd/reference/docker"
	"github.com/equinor/radix-vulnerability-scanner/pkg/registry"
)

type DockerConfig struct {
	Auths DockerAuthConfig `json:"auths"`
}

// DockerAuthConfig defines a map of registry names and authentication information
type DockerAuthConfig map[string]DockerAuthConfigEntry

// DockerAuthConfigEntry contains username and password for a docker registry
type DockerAuthConfigEntry struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

func New() *DockerConfig {
	return &DockerConfig{
		Auths: map[string]DockerAuthConfigEntry{},
	}
}

func (c *DockerConfig) AddAuth(registry, username, password string) *DockerConfig {
	c.Auths[registry] = DockerAuthConfigEntry{Username: username, Password: password}
	return c
}

// NewFromFile attempts to read docker configJSON from a given file path.
func NewFromFile(filePath string) (cfg *DockerConfig, err error) {
	var contents []byte

	if contents, err = os.ReadFile(filePath); err != nil {
		return nil, err
	}
	return NewFromBytes(contents)
}

// NewFromBytes attempts to unmarshal a slice of bytes to a DockerConfig.
func NewFromBytes(contents []byte) (*DockerConfig, error) {
	var cfgJSON DockerConfig
	if err := json.Unmarshal(contents, &cfgJSON); err != nil {
		return nil, errors.New("error occurred while trying to unmarshal json")
	}
	return &cfgJSON, nil
}

func (c *DockerConfig) GetAuth(_ context.Context, image string) (*registry.Auth, error) {
	named, err := docker.ParseDockerRef(image)
	if err != nil {
		return nil, err
	}
	registryName := docker.Domain(named)

	if len(c.Auths) > 0 {
		if auth, found := c.Auths[registryName]; found {
			return &registry.Auth{Username: auth.Username, Password: auth.Password}, nil
		}
	}

	return nil, nil
}
