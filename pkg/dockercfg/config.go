package dockercfg

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"strings"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azidentity"
	"github.com/containerd/containerd/reference/docker"
	"github.com/equinor/radix-vulnerability-scanner/pkg/utils/logwriter"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

var (
	errFailedToExecuteCredentialHelper = fmt.Errorf("failed to execute docker credential helper")
)

type DockerConfig struct {
	Auths       DockerAuthConfig                 `json:"auths"`
	CredHelpers map[string]CredHelperConfigEntry `json:"credHelpers"`
}

// DockerAuthConfig defines a map of registry names and authentication information
type DockerAuthConfig map[string]DockerAuthConfigEntry

// DockerAuthConfigEntry contains username and password for a docker registry
type DockerAuthConfigEntry struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// CredHelperConfigEntry contains name of docker-credential helper to fetch jwt for a docker registry
type CredHelperConfigEntry string

// ReadDockerAuthConfigFromFile attempts to read docker configJSON from a given file path.
func ReadDockerAuthConfigFromFile(filePath string) (cfg DockerConfig, err error) {
	var contents []byte

	if contents, err = os.ReadFile(filePath); err != nil {
		return DockerConfig{}, err
	}
	return ReadDockerAuthConfigFromBytes(contents)
}

// ReadDockerAuthConfigFromBytes attempts to unmarshal a slice of bytes to a DockerConfig.
func ReadDockerAuthConfigFromBytes(contents []byte) (cfg DockerConfig, err error) {
	var cfgJSON DockerConfig
	if err = json.Unmarshal(contents, &cfgJSON); err != nil {
		return DockerConfig{}, errors.New("error occurred while trying to unmarshal json")
	}
	return
}

type credentialHelperResult struct {
	ServerURL string `json:"ServerURL"`
	Username  string `json:"Username"`
	Password  string `json:"Password"`
}

func (c DockerConfig) GetAuth(ctx context.Context, image string) (DockerAuthConfigEntry, error) {
	named, err := docker.ParseDockerRef(image)
	if err != nil {
		return DockerAuthConfigEntry{}, err
	}
	registry := docker.Domain(named)

	if len(c.Auths) > 0 {
		if auth, found := c.Auths[registry]; found {
			return auth, nil
		}
	}

	if len(c.CredHelpers) > 0 {
		if helper, found := c.CredHelpers[registry]; found {
			executable := fmt.Sprintf("docker-credential-%s", helper)
			log.Ctx(ctx).Debug().Msgf("Getting credentials for %s with %s", registry, executable)

			buf := &bytes.Buffer{}
			cmd := exec.CommandContext(ctx, executable, "get")
			cmd.Stdin = strings.NewReader(registry)
			cmd.Stdout = buf
			cmd.Stderr = logwriter.New(zerolog.Ctx(ctx), zerolog.ErrorLevel)

			err := cmd.Wait()
			log.Trace().Stringer("result", buf).Err(err).Str("credetial_helper", executable).Msg("docker credential helper executed")
			if err != nil {
				return DockerAuthConfigEntry{}, fmt.Errorf("%w: Failed to get credentials for image %s with %s: %w", errFailedToExecuteCredentialHelper, registry, executable, err)
			}

			var result credentialHelperResult
			if err := json.Unmarshal(buf.Bytes(), &result); err != nil {
				return DockerAuthConfigEntry{}, err
			}

			return DockerAuthConfigEntry{
				Username: "00000000-0000-0000-0000-000000000000",
				Password: result.Password,
			}, nil
		}
	}

	return DockerAuthConfigEntry{}, nil
}

type ExchangeTokenResponse struct {
	RefreshToken string `json:"refresh_token"`
}

func ExchangeAADAccessTokenForACRRefreshToken(ctx context.Context, registryName string) (string, error) {

	cred, err := azidentity.NewDefaultAzureCredential(nil)
	if err != nil {
		return "", err
	}

	token, err := cred.GetToken(ctx, policy.TokenRequestOptions{Scopes: []string{
		"https://containerregistry.azure.net/.default",
	}})
	if err != nil {
		return "", err
	}

	formData := url.Values{}
	formData.Set("grant_type", "access_token")
	formData.Set("service", registryName)
	formData.Set("access_token", token.Token)
	body := strings.NewReader(formData.Encode())
	exchangeUrl := fmt.Sprintf("https://%s/oauth2/exchange", registryName)

	res, err := http.DefaultClient.Post(exchangeUrl, "application/x-www-form-urlencoded", body)
	if err != nil {
		return "", err
	}
	if !runtime.HasStatusCode(res, http.StatusOK) {
		err = runtime.NewResponseError(res)
		return "", err
	}

	bytes, err := io.ReadAll(res.Body)
	if err != nil {
		return "", err
	}

	var resToken ExchangeTokenResponse
	err = json.Unmarshal(bytes, &resToken)

	return resToken.RefreshToken, err
}
