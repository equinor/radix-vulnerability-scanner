package dockercfg

import (
	"context"
	"encoding/json"
	"errors"
	"os"

	"github.com/distribution/reference"
	"github.com/equinor/radix-vulnerability-scanner/pkg/registry"
	"github.com/rs/zerolog/log"
)

type Config struct {
	Auths AuthMap `json:"auths"`
}

// AuthMap defines a map of registry names and authentication information
type AuthMap map[string]AuthEntry

// AuthEntry contains username and password for a docker registry
type AuthEntry struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// NewFromFile attempts to read docker configJSON from a given file path.
func NewFromFile(filePath string) (cfg *Config, err error) {
	var contents []byte

	if contents, err = os.ReadFile(filePath); err != nil {
		return nil, err
	}
	return NewFromBytes(contents)
}

// NewFromBytes attempts to unmarshal a slice of bytes to a Config.
func NewFromBytes(contents []byte) (*Config, error) {
	var cfgJSON Config
	if err := json.Unmarshal(contents, &cfgJSON); err != nil {
		return nil, errors.New("error occurred while trying to unmarshal json")
	}
	return &cfgJSON, nil
}

func (c Config) GetAuth(ctx context.Context, image string) (*registry.Auth, error) {
	named, err := reference.ParseDockerRef(image)
	if err != nil {
		return nil, err
	}
	registryName := reference.Domain(named)

	if len(c.Auths) > 0 {
		if auth, found := c.Auths[registryName]; found {
			log.Ctx(ctx).Debug().Str("pkg", "dockercfg").Str("registry", registryName).Msg("found auth")
			return &registry.Auth{Username: auth.Username, Password: auth.Password}, nil
		}
	}

	return nil, nil
}
