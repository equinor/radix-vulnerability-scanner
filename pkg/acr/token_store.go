package acr

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"sync"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azidentity"
	"github.com/rs/zerolog/log"
	"golang.org/x/oauth2"

	"github.com/golang-jwt/jwt/v5"
)

var (
	errForbiddenRegistry = errors.New("forbidden registry")
)

type TokenStore struct {
	Credential azcore.TokenCredential
	Client     *http.Client

	mutex  sync.RWMutex
	tokens map[string]oauth2.TokenSource
	ctx    context.Context
}

func NewTokenStore(ctx context.Context) (*TokenStore, error) {
	cred, err := azidentity.NewDefaultAzureCredential(nil)
	if err != nil {
		return nil, err
	}
	return &TokenStore{
		Credential: cred,
		Client:     http.DefaultClient,

		mutex:  sync.RWMutex{},
		tokens: make(map[string]oauth2.TokenSource),

		ctx: ctx,
	}, nil
}

func (t *TokenStore) GetToken(registryName string) (string, error) {
	log.Ctx(t.ctx).Debug().Str("registry", registryName).Msg("Get ACR token")
	t.mutex.Lock()
	defer t.mutex.Unlock()

	_, ok := t.tokens[registryName]
	if !ok {
		t.tokens[registryName] = t.getTokenSource(t.ctx, registryName)
	}

	token, err := t.tokens[registryName].Token()
	if err != nil {
		return "", err
	}
	return token.AccessToken, nil
}

// TokenSourceFunc is a interface adapter for oauth2.TokenSource
type TokenSourceFunc func() (*oauth2.Token, error)

func (s TokenSourceFunc) Token() (*oauth2.Token, error) {
	return s()
}

func (t *TokenStore) getTokenSource(ctx context.Context, registryName string) oauth2.TokenSource {
	return TokenSourceFunc(func() (*oauth2.Token, error) {
		log.Ctx(ctx).Debug().Str("registry", registryName).Msg("Fetching new ACR token")

		adToken, err := t.Credential.GetToken(ctx, policy.TokenRequestOptions{Scopes: []string{
			"https://containerregistry.azure.net/.default",
		}})
		if err != nil {
			return nil, err
		}

		acrToken, err := t.exchangeTokenWithRefreshToken(ctx, registryName, adToken)
		if err != nil {
			return nil, err
		}

		expirationTime, err := getTokenExpiration(acrToken)
		if err != nil {
			return nil, err
		}

		return &oauth2.Token{
			AccessToken:  acrToken,
			TokenType:    "",
			RefreshToken: "",
			Expiry:       expirationTime,
		}, err
	})
}

func (t *TokenStore) exchangeTokenWithRefreshToken(ctx context.Context, registryName string, token azcore.AccessToken) (string, error) {
	// Make sure we never sends tokens other places than to Azure Container Registry
	if !strings.HasSuffix(registryName, ".azurecr.io") {
		log.Ctx(ctx).Error().Str("registry", registryName).Msg("trying to use radix-wi-env helper on a forbidden registry")
		return "", errForbiddenRegistry
	}

	formData := url.Values{}
	formData.Set("grant_type", "access_token")
	formData.Set("service", registryName)
	formData.Set("access_token", token.Token)

	exchangeUrl := fmt.Sprintf("https://%s/oauth2/exchange", registryName)
	res, err := t.Client.PostForm(exchangeUrl, formData)
	if err != nil {
		return "", err
	}
	defer res.Body.Close()

	if !runtime.HasStatusCode(res, http.StatusOK) {
		err = runtime.NewResponseError(res)
		return "", err
	}

	bytes, err := io.ReadAll(res.Body)
	if err != nil {
		return "", err
	}

	var resToken oauth2.Token
	err = json.Unmarshal(bytes, &resToken)

	// ACR Token exchange only returns a refresh token, we will use it as our Access token later on
	return resToken.RefreshToken, err
}

func getTokenExpiration(acrToken string) (time.Time, error) {
	// Will be verified by ACR
	token, _, err := jwt.NewParser().ParseUnverified(acrToken, &jwt.MapClaims{})
	if err != nil {
		return time.Time{}, err
	}

	expirationTime, err := token.Claims.GetExpirationTime()
	if err != nil {
		return time.Time{}, err
	}
	return expirationTime.Time, nil
}
