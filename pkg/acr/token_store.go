package acr

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"sync"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azidentity"

	"github.com/golang-jwt/jwt/v5"
)

type ExchangeTokenResponse struct {
	RefreshToken string `json:"refresh_token"`
}

type TokenStore struct {
	Credential azcore.TokenCredential
	Client     *http.Client

	mutex     sync.RWMutex
	adTokens  map[string]Token
	acrTokens map[string]Token
}

type Token struct {
	AccessToken string
	Expiry      time.Time
}

func NewTokenStore() (*TokenStore, error) {
	cred, err := azidentity.NewDefaultAzureCredential(nil)
	if err != nil {
		return nil, err
	}
	return &TokenStore{
		Credential: cred,
		Client:     http.DefaultClient,

		mutex:     sync.RWMutex{},
		acrTokens: map[string]Token{},
	}, nil
}

func (t *TokenStore) GetRefreshToken(ctx context.Context, registryName string) (string, error) {
	// check if we already have a valid token
	t.mutex.RLock()
	acrToken, ok := t.acrTokens[registryName]
	t.mutex.RUnlock()
	if ok && acrToken.Expiry.After(time.Now()) {
		return acrToken.AccessToken, nil
	}

	// valid for 86minutes / 5169sec
	// We dont need to cache AD tokens since they have a shorter lifespan than ACR Tokens
	adToken, err := t.Credential.GetToken(ctx, policy.TokenRequestOptions{Scopes: []string{
		"https://containerregistry.azure.net/.default",
	}})
	if err != nil {
		return "", err
	}

	// valid for 195min / 11700 sec
	refreshToken, err := t.exchangeTokenWithRefreshToken(registryName, adToken)
	if err != nil {
		return "", err
	}

	var claims = jwt.MapClaims{}
	// Will be verified by ACR
	token, _, err := jwt.NewParser().ParseUnverified(refreshToken, &claims)
	if err != nil {
		return "", err
	}
	expirationTime, err := token.Claims.GetExpirationTime()
	if err != nil {
		return "", err
	}

	t.mutex.Lock()
	t.acrTokens[registryName] = Token{refreshToken, expirationTime.Time.Add(-5 * time.Minute)}
	t.mutex.Unlock()

	return refreshToken, err
}

func (t *TokenStore) exchangeTokenWithRefreshToken(registryName string, token azcore.AccessToken) (string, error) {
	formData := url.Values{}
	formData.Set("grant_type", "access_token")
	formData.Set("service", registryName)
	formData.Set("access_token", token.Token)

	// Make sure we never sends tokens other places than to Azure Container Registry
	if !strings.HasSuffix(registryName, ".azurecr.io") {
		return "", errors.New("invalid registry")
	}

	exchangeUrl := fmt.Sprintf("https://%s/oauth2/exchange", registryName)
	res, err := t.Client.PostForm(exchangeUrl, formData)
	if err != nil {
		return "", err
	}
	defer res.Body.Close()

	if !runtime.HasStatusCode(res, http.StatusOK) {
		err = runtime.NewResponseError(res)
		return "", err
	}

	bytes, err := io.ReadAll(res.Body)
	if err != nil {
		return "", err
	}

	var resToken ExchangeTokenResponse
	err = json.Unmarshal(bytes, &resToken)

	return resToken.RefreshToken, err
}
