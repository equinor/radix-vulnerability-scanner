package scan

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"os/exec"

	"github.com/containerd/containerd/reference/docker"
	"github.com/equinor/radix-vulnerability-scanner/pkg/dockercfg"
	"github.com/sirupsen/logrus"
)

var _ Scanner = &snykScanner{}

type commandExecutor interface {
	Execute(ctx context.Context, command string, args []string, stdOutWriter io.Writer) error
}

type commandExecutorImpl struct{}

func (commandExecutorImpl) Execute(ctx context.Context, command string, args []string, stdOutWriter io.Writer) error {
	cmd := exec.CommandContext(ctx, command, args...)
	cmd.Stderr = logrus.NewEntry(logrus.StandardLogger()).WriterLevel(logrus.ErrorLevel)
	cmd.Stdout = stdOutWriter

	if err := cmd.Start(); err != nil {
		return err
	}

	return cmd.Wait()
}

type snykScanner struct {
	commonAuths dockercfg.DockerAuthConfig
	executor    commandExecutor
}

// NewSnyk create a Scanner that use SNYK to scan for vulnerabilities
func NewSnyk(commonAuths dockercfg.DockerAuthConfig) Scanner {
	return &snykScanner{commonAuths: commonAuths, executor: commandExecutorImpl{}}
}

func (s *snykScanner) Scan(ctx context.Context, image string, auths dockercfg.DockerAuthConfig) (*ScanResult, error) {

	// Try to get docker creds for image from common auths
	credArgs, err := s.getCredentialArgs(image, s.commonAuths)
	if err != nil {
		return nil, err
	}

	// If creds was not found in commonAuth, try to get creds from auths argument
	var credsFromAuthsArg bool
	if len(credArgs) == 0 {
		credArgs, err = s.getCredentialArgs(image, auths)
		if err != nil {
			return nil, err
		}
		if len(credArgs) > 0 {
			credsFromAuthsArg = true
		}
	}

	scanFn := func(ctx context.Context, args []string, buf io.Writer) error {
		if err := s.executeSnykWithArgs(ctx, args, buf); err != nil && !s.isSnykScanSuccessErr(err) {
			return err
		}

		return nil
	}

	testArgs := []string{"container", "test", "--json", image}
	var testArgsWithCreds []string
	testArgsWithCreds = append(testArgsWithCreds, testArgs...)
	testArgsWithCreds = append(testArgsWithCreds, credArgs...)
	buf := &bytes.Buffer{}

	if err := scanFn(ctx, testArgsWithCreds, buf); err != nil {
		// Rescan the image without credentials args if credentials were resolved from the `auths` parameter.
		// If invalid credentials are supplied for a public image (that requires no authentication), e.g. docker.io,
		// the scan will fail with an unauthorized error.
		// Example: a public image docker.io/redis:latest requires no authentication, but the `auths`
		// parameter contains invalid credentials for docker.io. Even if redis:latest is public, the invalid credentials
		// from the `auths` parameter causes the scan to fail. We'll therefore try to do a second scan
		// without supplying credential arguments
		if credsFromAuthsArg {
			buf = &bytes.Buffer{}
			err = scanFn(ctx, testArgs, buf)
		}

		if err != nil {
			return nil, err
		}
	}

	var result ScanResult
	if err := json.Unmarshal(buf.Bytes(), &result); err != nil {
		return nil, err
	}

	return &result, nil
}

func (s *snykScanner) getCredentialArgs(image string, auths dockercfg.DockerAuthConfig) ([]string, error) {
	auth, err := s.getDockerAuth(image, auths)
	if err != nil {
		return nil, err
	}

	if auth.Username != "" && auth.Password != "" {
		return []string{fmt.Sprintf("--username=%v", auth.Username), fmt.Sprintf("--password=%v", auth.Password)}, nil
	}
	return nil, nil
}

func (s *snykScanner) getDockerAuth(image string, auths dockercfg.DockerAuthConfig) (dockercfg.DockerAuthConfigEntry, error) {
	if len(auths) > 0 {
		named, err := docker.ParseDockerRef(image)
		if err != nil {
			return dockercfg.DockerAuthConfigEntry{}, err
		}

		registry := docker.Domain(named)
		if auth, found := auths[registry]; found {
			return auth, nil
		}
	}

	return dockercfg.DockerAuthConfigEntry{}, nil
}

func (s *snykScanner) executeSnykWithArgs(ctx context.Context, args []string, stdOutWriter io.Writer) error {
	return s.executor.Execute(ctx, "snyk", args, stdOutWriter)
}

func (s *snykScanner) isSnykScanSuccessErr(err error) bool {
	if err == nil {
		return true
	}

	if exitErr, ok := err.(*exec.ExitError); ok {
		exitCode := exitErr.ExitCode()
		// SNYK cli returns:
		// 0 when no vulnerabilities found
		// 1 when vulnerabilities were found
		// >1 when scan failed, e.g. auth error
		return exitCode == 0 || exitCode == 1
	}

	return false
}
