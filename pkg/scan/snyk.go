package scan

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"os/exec"

	"github.com/containerd/containerd/reference/docker"
	"github.com/sirupsen/logrus"
)

var _ Scanner = &snykScanner{}

type commandExecutor interface {
	Execute(ctx context.Context, command string, args []string, stdOutWriter io.Writer) error
}

type commandExecutorImpl struct{}

func (commandExecutorImpl) Execute(ctx context.Context, command string, args []string, stdOutWriter io.Writer) error {
	cmd := exec.CommandContext(ctx, command, args...)
	cmd.Stderr = logrus.NewEntry(logrus.StandardLogger()).WriterLevel(logrus.ErrorLevel)
	cmd.Stdout = stdOutWriter

	if err := cmd.Start(); err != nil {
		return err
	}

	return cmd.Wait()
}

type snykScanner struct {
	auths    DockerConfig
	executor commandExecutor
}

// NewSnyk create a Scanner that use SNYK to scan for vulnerabilities
func NewSnyk(auths DockerConfig) Scanner {
	return &snykScanner{auths: auths, executor: commandExecutorImpl{}}
}

func (s *snykScanner) Scan(ctx context.Context, image string) (*ScanResult, error) {
	args := []string{"container", "test", "--json", image}

	credArgs, err := s.getCredentialArgs(image)
	if err != nil {
		return nil, err
	}

	args = append(args, credArgs...)

	buf := &bytes.Buffer{}
	if err := s.executeSnykWithArgs(ctx, args, buf); err != nil && !s.isSnykScanSuccessErr(err) {
		return nil, err
	}

	var result ScanResult
	if err := json.Unmarshal(buf.Bytes(), &result); err != nil {
		return nil, err
	}

	return &result, nil
}

func (s *snykScanner) getCredentialArgs(image string) ([]string, error) {
	auth, err := s.getDockerAuth(image)
	if err != nil {
		return nil, err
	}

	if auth.Username != "" && auth.Password != "" {
		return []string{fmt.Sprintf("--username=%v", auth.Username), fmt.Sprintf("--password=%v", auth.Password)}, nil
	}
	return nil, nil
}

func (s *snykScanner) getDockerAuth(image string) (DockerConfigEntry, error) {
	if len(s.auths) > 0 {
		named, err := docker.ParseDockerRef(image)
		if err != nil {
			return DockerConfigEntry{}, err
		}

		registry := docker.Domain(named)
		if auth, found := s.auths[registry]; found {
			return auth, nil
		}
	}

	return DockerConfigEntry{}, nil
}

func (s *snykScanner) executeSnykWithArgs(ctx context.Context, args []string, stdOutWriter io.Writer) error {
	return s.executor.Execute(ctx, "snyk", args, stdOutWriter)
}

func (s *snykScanner) isSnykScanSuccessErr(err error) bool {
	if err == nil {
		return true
	}

	if exitErr, ok := err.(*exec.ExitError); ok {
		exitCode := exitErr.ExitCode()
		return exitCode == 0 || exitCode == 1
	}

	return false
}
