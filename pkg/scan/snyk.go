package scan

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"os/exec"

	"github.com/containerd/containerd/reference/docker"
	"github.com/sirupsen/logrus"
)

var _ Scanner = &snykScanner{}

type executorFunc func(ctx context.Context, command string, args []string, stdOutWriter io.Writer) error

var defaultExecutor = func(ctx context.Context, command string, args []string, stdOutWriter io.Writer) error {
	cmd := exec.CommandContext(ctx, command, args...)
	cmd.Stderr = logrus.NewEntry(logrus.StandardLogger()).WriterLevel(logrus.ErrorLevel)
	cmd.Stdout = stdOutWriter

	if err := cmd.Start(); err != nil {
		return err
	}

	return cmd.Wait()
}

type snykScanner struct {
	auths    DockerConfig
	executor executorFunc
}

// NewSnyk create a Scanner that use SNYK to scan for vulnerabilities
func NewSnyk(auths DockerConfig) Scanner {
	return &snykScanner{auths: auths, executor: defaultExecutor}
}

func (s *snykScanner) Scan(ctx context.Context, image string) (*ScanResult, error) {
	args := []string{"container", "test", "--json", image}
	args = append(args, s.getCredentialArgs(image)...)

	buf := &bytes.Buffer{}
	if err := s.executeSnykWithArgs(ctx, args, buf); err != nil && !s.isSnykScanSuccessErr(err) {
		return nil, err
	}

	var result ScanResult
	if err := json.Unmarshal(buf.Bytes(), &result); err != nil {
		return nil, err
	}

	return &result, nil
}

func (s *snykScanner) getCredentialArgs(image string) []string {
	auth := s.getDockerAuth(image)
	if auth.Username != "" && auth.Password != "" {
		return []string{fmt.Sprintf("--username=%v", auth.Username), fmt.Sprintf("--password=%v", auth.Password)}
	}
	return nil
}

func (s *snykScanner) getDockerAuth(image string) DockerConfigEntry {
	if len(s.auths) > 0 {
		named, _ := docker.ParseDockerRef(image)
		registry := docker.Domain(named)
		if auth, found := s.auths[registry]; found {
			return auth
		}
	}

	return DockerConfigEntry{}
}

func (s *snykScanner) executeSnykWithArgs(ctx context.Context, args []string, stdOutWriter io.Writer) error {
	execCmd := s.executor
	if execCmd == nil {
		execCmd = defaultExecutor
	}
	return execCmd(ctx, "snyk", args, stdOutWriter)
}

func (s *snykScanner) isSnykScanSuccessErr(err error) bool {
	if err == nil {
		return true
	}

	if exitErr, ok := err.(*exec.ExitError); ok {
		exitCode := exitErr.ExitCode()
		return exitCode == 0 || exitCode == 1
	}

	return false
}
