package scan

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"os/exec"
	"time"

	"github.com/sirupsen/logrus"
)

var _ Scanner = &SnykScanner{}

type SnykScanner struct {
}

func NewSnyk() *SnykScanner {
	return &SnykScanner{}
}

func (s *SnykScanner) SetAPIToken(token string) error {
	args := []string{"config", "set", token}
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	return s.executeSnykWithArgs(ctx, args, nil)
}

func (s *SnykScanner) Scan(ctx context.Context, image string) (*ScanResult, error) {
	args := []string{"container", "test", "--json", image}

	buf := &bytes.Buffer{}

	if err := s.executeSnykWithArgs(ctx, args, buf); err != nil && !s.isSnykScanSuccessErr(err) {
		logrus.Error(err)
		return nil, err
	}

	var result ScanResult
	if err := json.Unmarshal(buf.Bytes(), &result); err != nil {
		return nil, err
	}

	return &result, nil
}

func (*SnykScanner) executeSnykWithArgs(ctx context.Context, args []string, stdOutWriter io.Writer) error {
	cmd := exec.CommandContext(ctx, "snyk", args...)
	cmd.Stderr = logrus.NewEntry(logrus.StandardLogger()).WriterLevel(logrus.ErrorLevel)
	cmd.Stdout = stdOutWriter

	if err := cmd.Start(); err != nil {
		return err
	}

	return cmd.Wait()
}

func (s *SnykScanner) isSnykScanSuccessErr(err error) bool {
	if err == nil {
		return true
	}

	if exitErr, ok := err.(*exec.ExitError); ok {
		exitCode := exitErr.ExitCode()
		return exitCode == 0 || exitCode == 1
	}

	return false
}
