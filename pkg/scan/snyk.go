package scan

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"os/exec"

	"github.com/equinor/radix-vulnerability-scanner/pkg/dockercfg"
	"github.com/equinor/radix-vulnerability-scanner/pkg/registry"
	"github.com/equinor/radix-vulnerability-scanner/pkg/scan/executor"
	"github.com/rs/zerolog/log"
)

var _ Scanner = &SnykScanner{}

type SnykScanner struct {
	executor          executor.Executor
	commonDockerAuths []registry.AuthProvider
}

type SnykOption func(*SnykScanner)

func WithAuthProvider(auth registry.AuthProvider) SnykOption {
	return func(ss *SnykScanner) {
		ss.commonDockerAuths = append(ss.commonDockerAuths, auth)
	}
}

// NewSnykScanner create a Scanner that use SNYK to scan for vulnerabilities
func NewSnykScanner(executor executor.Executor, opts ...SnykOption) *SnykScanner {
	scanner := &SnykScanner{executor: executor}

	for _, opt := range opts {
		opt(scanner)
	}

	return scanner
}

func (s *SnykScanner) Scan(ctx context.Context, image string, dockerConfig dockercfg.Config) (*ScanResult, error) {

	auths := append(s.commonDockerAuths, &dockerConfig)
	var credArgs []string
	// Try to get docker creds for image from common auths
	for _, auth := range auths {
		tmpCreds, err := s.getCredentialArgs(image, auth)
		if err != nil {
			return nil, err
		}
		credArgs = tmpCreds
		if len(credArgs) > 0 {
			break
		}
	}

	scanFn := func(ctx context.Context, args []string, buf io.Writer) error {
		if err := s.executeSnykWithArgs(ctx, args, buf); err != nil && !s.isSnykScanSuccessErr(err) {
			return err
		}

		return nil
	}

	log.Ctx(ctx).Debug().Str("pkg", "scan").Str("image", image).Msg("scanning image")
	testArgs := []string{"container", "test", "--json", image}
	var testArgsWithCreds []string
	testArgsWithCreds = append(testArgsWithCreds, testArgs...)
	testArgsWithCreds = append(testArgsWithCreds, credArgs...)
	buf := &bytes.Buffer{}
	err := scanFn(ctx, testArgsWithCreds, buf)
	log.Trace().Str("pkg", "scan").Stringer("result", buf).Strs("args", testArgsWithCreds).Err(err).Msg("scan completed")

	if err != nil {
		if len(credArgs) == 0 {
			return nil, err
		}

		// Rescan the image without credentials args if credentials were resolved from the `auths` parameter.
		// If invalid credentials are supplied for a public image (that requires no authentication), e.g. docker.io,
		// the scan will fail with an unauthorized error.
		// Example: a public image docker.io/redis:latest requires no authentication, but the `auths`
		// parameter contains invalid credentials for docker.io. Even if redis:latest is public, the invalid credentials
		// from the `auths` parameter causes the scan to fail. We'll therefore try to do a second scan
		// without supplying credential arguments
		log.Ctx(ctx).Debug().Str("pkg", "scan").Str("image", image).Msg("scanning image again without creds")
		buf = &bytes.Buffer{}
		err = scanFn(ctx, testArgs, buf)
		log.Trace().Str("pkg", "scan").Stringer("result", buf).Strs("args", testArgsWithCreds).Err(err).Msg("retry scan completed")
		if err != nil {
			return nil, err
		}
	}

	var result ScanResult
	if err := json.Unmarshal(buf.Bytes(), &result); err != nil {
		return nil, err
	}

	return &result, nil
}

func (s *SnykScanner) getCredentialArgs(image string, authProvider registry.AuthProvider) ([]string, error) {
	auth, err := authProvider.GetAuth(context.Background(), image)
	if err != nil {
		return nil, err
	}

	if auth != nil && auth.Username != "" && auth.Password != "" {
		return []string{fmt.Sprintf("--username=%v", auth.Username), fmt.Sprintf("--password=%v", auth.Password)}, nil
	}
	return nil, nil
}

func (s *SnykScanner) executeSnykWithArgs(ctx context.Context, args []string, stdOutWriter io.Writer) error {
	return s.executor.Execute(ctx, "snyk", args, stdOutWriter)
}

func (s *SnykScanner) isSnykScanSuccessErr(err error) bool {
	if err == nil {
		return true
	}

	if exitErr, ok := err.(*exec.ExitError); ok {
		exitCode := exitErr.ExitCode()
		// SNYK cli returns:
		// 0 when no vulnerabilities found
		// 1 when vulnerabilities were found
		// >1 when scan failed, e.g. auth error
		return exitCode == 0 || exitCode == 1
	}

	return false
}
