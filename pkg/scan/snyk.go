package scan

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"os/exec"

	"github.com/equinor/radix-vulnerability-scanner/pkg/dockercfg"
	"github.com/equinor/radix-vulnerability-scanner/pkg/tokenstore"
	"github.com/equinor/radix-vulnerability-scanner/pkg/utils/logwriter"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

var _ Scanner = &snykScanner{}

type commandExecutor interface {
	Execute(ctx context.Context, command string, args []string, stdOutWriter io.Writer) error
}

type commandExecutorImpl struct{}

func (commandExecutorImpl) Execute(ctx context.Context, command string, args []string, stdOutWriter io.Writer) error {
	cmd := exec.CommandContext(ctx, command, args...)
	cmd.Stderr = logwriter.New(zerolog.Ctx(ctx), zerolog.ErrorLevel)
	cmd.Stdout = stdOutWriter

	if err := cmd.Start(); err != nil {
		return err
	}

	return cmd.Wait()
}

type snykScanner struct {
	commonDockerConfig dockercfg.DockerConfig
	executor           commandExecutor
	tokenStore         *tokenstore.TokenStore
}

// NewSnyk create a Scanner that use SNYK to scan for vulnerabilities
func NewSnyk(commonAuths dockercfg.DockerConfig, tokenStore *tokenstore.TokenStore) Scanner {
	return &snykScanner{commonDockerConfig: commonAuths, executor: commandExecutorImpl{}, tokenStore: tokenStore}
}

func (s *snykScanner) Scan(ctx context.Context, image string, dockerConfig dockercfg.DockerConfig) (*ScanResult, error) {

	// Try to get docker creds for image from common auths
	credArgs, err := s.getCredentialArgs(image, s.commonDockerConfig)
	if err != nil {
		return nil, err
	}

	// If creds was not found in dockerConfig, try to get creds from auths argument
	var credsFromAuthsArg bool
	if len(credArgs) == 0 {
		credArgs, err = s.getCredentialArgs(image, dockerConfig)
		if err != nil {
			return nil, err
		}
		if len(credArgs) > 0 {
			credsFromAuthsArg = true
		}
	}

	scanFn := func(ctx context.Context, args []string, buf io.Writer) error {
		if err := s.executeSnykWithArgs(ctx, args, buf); err != nil && !s.isSnykScanSuccessErr(err) {
			return err
		}

		return nil
	}

	testArgs := []string{"container", "test", "--json", image}
	var testArgsWithCreds []string
	testArgsWithCreds = append(testArgsWithCreds, testArgs...)
	testArgsWithCreds = append(testArgsWithCreds, credArgs...)
	buf := &bytes.Buffer{}
	err = scanFn(ctx, testArgsWithCreds, buf)
	log.Trace().Stringer("result", buf).Strs("args", testArgsWithCreds).Err(err).Msg("scan completed")
	if err != nil {
		// Rescan the image without credentials args if credentials were resolved from the `auths` parameter.
		// If invalid credentials are supplied for a public image (that requires no authentication), e.g. docker.io,
		// the scan will fail with an unauthorized error.
		// Example: a public image docker.io/redis:latest requires no authentication, but the `auths`
		// parameter contains invalid credentials for docker.io. Even if redis:latest is public, the invalid credentials
		// from the `auths` parameter causes the scan to fail. We'll therefore try to do a second scan
		// without supplying credential arguments
		if credsFromAuthsArg {
			buf = &bytes.Buffer{}
			err = scanFn(ctx, testArgs, buf)
			log.Trace().Stringer("result", buf).Strs("args", testArgsWithCreds).Err(err).Msg("retry scan completed")
		}

		if err != nil {
			return nil, err
		}
	}

	var result ScanResult
	if err := json.Unmarshal(buf.Bytes(), &result); err != nil {
		return nil, err
	}

	return &result, nil
}

func (s *snykScanner) getCredentialArgs(image string, dockerConfig dockercfg.DockerConfig) ([]string, error) {
	auth, err := dockerConfig.GetAuth(image, s.tokenStore)
	if err != nil {
		return nil, err
	}

	if auth.Username != "" && auth.Password != "" {
		return []string{fmt.Sprintf("--username=%v", auth.Username), fmt.Sprintf("--password=%v", auth.Password)}, nil
	}
	return nil, nil
}

func (s *snykScanner) executeSnykWithArgs(ctx context.Context, args []string, stdOutWriter io.Writer) error {
	return s.executor.Execute(ctx, "snyk", args, stdOutWriter)
}

func (s *snykScanner) isSnykScanSuccessErr(err error) bool {
	if err == nil {
		return true
	}

	if exitErr, ok := err.(*exec.ExitError); ok {
		exitCode := exitErr.ExitCode()
		// SNYK cli returns:
		// 0 when no vulnerabilities found
		// 1 when vulnerabilities were found
		// >1 when scan failed, e.g. auth error
		return exitCode == 0 || exitCode == 1
	}

	return false
}
