package scan

import (
	"context"
	"encoding/json"
	"errors"
	"io"
	"testing"

	"github.com/equinor/radix-common/utils"
	"github.com/equinor/radix-vulnerability-scanner/pkg/dockercfg"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

type mockCommandExec struct {
	mock.Mock
}

func (c *mockCommandExec) Execute(ctx context.Context, command string, args []string, stdOutWriter io.Writer) error {
	mockArgs := c.Called(ctx, command, args, stdOutWriter)
	return mockArgs.Error(0)
}

func Test_NewSnyk(t *testing.T) {
	dockerCfg := dockercfg.DockerConfig{Auths: dockercfg.DockerAuthConfig{"registry": dockercfg.DockerAuthConfigEntry{}}}
	sut := NewSnyk(dockerCfg, nil).(*snykScanner)
	assert.Equal(t, dockerCfg, sut.commonDockerConfig)
	assert.IsType(t, commandExecutorImpl{}, sut.executor)
}

func Test_SnykScanImageWithCommonAuthEntry(t *testing.T) {
	dockerCfg := dockercfg.DockerConfig{Auths: dockercfg.DockerAuthConfig{
		"my.registry.com":      dockercfg.DockerAuthConfigEntry{Username: "reguser", Password: "regpwd"},
		"another.registry.com": dockercfg.DockerAuthConfigEntry{Username: "someuser", Password: "somepwd"},
	}}

	expectedArgs := []string{"container", "test", "--json", "my.registry.com/image:tag", "--username=reguser", "--password=regpwd"}
	cmdExec := new(mockCommandExec)
	call := cmdExec.On("Execute", mock.Anything, "snyk", expectedArgs, mock.Anything).Return(nil).Times(1)
	call.RunFn = func(a mock.Arguments) {
		_, err := a.Get(3).(io.Writer).Write([]byte("{}"))
		require.NoError(t, err)
	}
	sut := &snykScanner{commonDockerConfig: dockerCfg, executor: cmdExec}
	_, actualErr := sut.Scan(context.Background(), "my.registry.com/image:tag", dockercfg.DockerConfig{})
	assert.NoError(t, actualErr)
	cmdExec.AssertExpectations(t)
}

func Test_SnykScanImageWithCommonAuthEntryAndArgumentAuth(t *testing.T) {
	dockerCfg := dockercfg.DockerConfig{Auths: dockercfg.DockerAuthConfig{
		"my.registry.com": dockercfg.DockerAuthConfigEntry{Username: "reguser", Password: "regpwd"},
	}}

	expectedArgs := []string{"container", "test", "--json", "my.registry.com/image:tag", "--username=reguser", "--password=regpwd"}
	cmdExec := new(mockCommandExec)
	call := cmdExec.On("Execute", mock.Anything, "snyk", expectedArgs, mock.Anything).Return(nil).Times(1)
	call.RunFn = func(a mock.Arguments) {
		_, err := a.Get(3).(io.Writer).Write([]byte("{}"))
		require.NoError(t, err)
	}
	sut := &snykScanner{commonDockerConfig: dockerCfg, executor: cmdExec}
	_, actualErr := sut.Scan(context.Background(), "my.registry.com/image:tag", dockercfg.DockerConfig{Auths: dockercfg.DockerAuthConfig{"my.registry.com": dockercfg.DockerAuthConfigEntry{Username: "anotheruser", Password: "anotherpwd"}}})
	assert.NoError(t, actualErr)
	cmdExec.AssertExpectations(t)
}

func Test_SnykScanImageWithNoCommonAuthEntryButWithArgumentAuth(t *testing.T) {
	dockerCfg := dockercfg.DockerConfig{}

	expectedArgs := []string{"container", "test", "--json", "my.registry.com/image:tag", "--username=anotheruser", "--password=anotherpwd"}
	cmdExec := new(mockCommandExec)
	call := cmdExec.On("Execute", mock.Anything, "snyk", expectedArgs, mock.Anything).Return(nil).Times(1)
	call.RunFn = func(a mock.Arguments) {
		_, err := a.Get(3).(io.Writer).Write([]byte("{}"))
		require.NoError(t, err)
	}
	sut := &snykScanner{commonDockerConfig: dockerCfg, executor: cmdExec}
	_, actualErr := sut.Scan(context.Background(), "my.registry.com/image:tag", dockercfg.DockerConfig{Auths: dockercfg.DockerAuthConfig{"my.registry.com": dockercfg.DockerAuthConfigEntry{Username: "anotheruser", Password: "anotherpwd"}}})
	assert.NoError(t, actualErr)
	cmdExec.AssertExpectations(t)
}

func Test_SnykScanImageAuthArgFailsShouldRetryWithoutAuth(t *testing.T) {
	dockerCfg := dockercfg.DockerConfig{}

	cmdExec := new(mockCommandExec)
	expectedArgsWithAuth := []string{"container", "test", "--json", "my.registry.com/image:tag", "--username=anotheruser", "--password=anotherpwd"}
	cmdExec.On("Execute", mock.Anything, "snyk", expectedArgsWithAuth, mock.Anything).Return(errors.New("any error")).Times(1)

	expectedArgsWithoutAuth := []string{"container", "test", "--json", "my.registry.com/image:tag"}
	call := cmdExec.On("Execute", mock.Anything, "snyk", expectedArgsWithoutAuth, mock.Anything).Return(nil).Times(1)
	call.RunFn = func(a mock.Arguments) {
		_, err := a.Get(3).(io.Writer).Write([]byte("{}"))
		require.NoError(t, err)
	}
	sut := &snykScanner{commonDockerConfig: dockerCfg, executor: cmdExec}
	_, actualErr := sut.Scan(context.Background(), "my.registry.com/image:tag", dockercfg.DockerConfig{Auths: map[string]dockercfg.DockerAuthConfigEntry{"my.registry.com": {Username: "anotheruser", Password: "anotherpwd"}}})
	assert.NoError(t, actualErr)
	cmdExec.AssertExpectations(t)
}

func Test_SnykScanImageWithNoAuthEntry(t *testing.T) {
	dockerCfg := dockercfg.DockerConfig{
		Auths: map[string]dockercfg.DockerAuthConfigEntry{
			"another.registry.com": dockercfg.DockerAuthConfigEntry{Username: "someuser", Password: "somepwd"},
		},
	}

	expectedArgs := []string{"container", "test", "--json", "my.registry.com/image:tag"}
	cmdExec := new(mockCommandExec)
	call := cmdExec.On("Execute", mock.Anything, "snyk", expectedArgs, mock.Anything).Return(nil).Times(1)
	call.RunFn = func(a mock.Arguments) {
		_, err := a.Get(3).(io.Writer).Write([]byte("{}"))
		require.NoError(t, err)
	}
	sut := &snykScanner{commonDockerConfig: dockerCfg, executor: cmdExec}
	_, actualErr := sut.Scan(context.Background(), "my.registry.com/image:tag", dockercfg.DockerConfig{})
	assert.NoError(t, actualErr)
	cmdExec.AssertExpectations(t)
}

func Test_SnykScanImageWithInvalidImageStringReturnsError(t *testing.T) {
	dockerCfg := dockercfg.DockerConfig{
		Auths: map[string]dockercfg.DockerAuthConfigEntry{
			"any.registry.com": {Username: "someuser", Password: "somepwd"},
		},
	}
	cmdExec := new(mockCommandExec)
	cmdExec.On("Execute", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(nil).Times(0)
	sut := &snykScanner{commonDockerConfig: dockerCfg, executor: cmdExec}
	_, actualErr := sut.Scan(context.Background(), "my.registry.com/image:tag", dockercfg.DockerConfig{})
	assert.Error(t, actualErr)
	cmdExec.AssertExpectations(t)
}

func Test_SnykScanErrorFromExecutorReturned(t *testing.T) {
	dockerCfg := dockercfg.DockerConfig{}
	expectedErr := errors.New("any error")
	cmdExec := new(mockCommandExec)
	cmdExec.On("Execute", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(expectedErr).Times(1)
	sut := &snykScanner{commonDockerConfig: dockerCfg, executor: cmdExec}
	_, actualErr := sut.Scan(context.Background(), "my.registry.com/image:test", dockercfg.DockerConfig{})
	assert.ErrorIs(t, expectedErr, actualErr)
	cmdExec.AssertExpectations(t)
}

func Test_SnykScanStdOutFromExecutorUnmarshalled(t *testing.T) {
	dockerCfg := dockercfg.DockerConfig{}
	expectedResults := ScanResult{
		Docker:          DockerInfo{BaseImage: utils.StringPtr("base")},
		Vulnerabilities: []Vulnerability{{Id: "id1"}},
	}
	cmdExec := new(mockCommandExec)
	call := cmdExec.On("Execute", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(nil).Times(1)
	call.RunFn = func(a mock.Arguments) {
		resultBytes, err := json.Marshal(&expectedResults)
		require.NoError(t, err)
		_, err = a.Get(3).(io.Writer).Write(resultBytes)
		require.NoError(t, err)
	}
	sut := &snykScanner{commonDockerConfig: dockerCfg, executor: cmdExec}
	actualScanResult, actualErr := sut.Scan(context.Background(), "my.registry.com/image:test", dockercfg.DockerConfig{})
	assert.NoError(t, actualErr)
	assert.Equal(t, expectedResults, *actualScanResult)
	cmdExec.AssertExpectations(t)
}
