package scan

import (
	"context"
	"encoding/json"
	"errors"
	"io"
	"testing"

	"github.com/equinor/radix-common/utils"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type mockCommandExec struct {
	mock.Mock
}

func (c *mockCommandExec) Execute(ctx context.Context, command string, args []string, stdOutWriter io.Writer) error {
	mockArgs := c.Called(ctx, command, args, stdOutWriter)
	return mockArgs.Error(0)
}

func Test_NewSnyk(t *testing.T) {
	dockerCfg := DockerConfig{"registry": DockerConfigEntry{}}
	sut := NewSnyk(dockerCfg).(*snykScanner)
	assert.Equal(t, dockerCfg, sut.auths)
	assert.IsType(t, commandExecutorImpl{}, sut.executor)
}

func Test_SnykScanImageWithExistingAuthEntry(t *testing.T) {
	dockerCfg := DockerConfig{
		"my.registry.com":      DockerConfigEntry{Username: "reguser", Password: "regpwd"},
		"another.registry.com": DockerConfigEntry{Username: "someuser", Password: "somepwd"},
	}

	expectedArgs := []string{"container", "test", "--json", "my.registry.com/image:tag", "--username=reguser", "--password=regpwd"}
	cmdExec := new(mockCommandExec)
	call := cmdExec.On("Execute", mock.Anything, "snyk", expectedArgs, mock.Anything).Return(nil).Times(1)
	call.RunFn = func(a mock.Arguments) {
		a.Get(3).(io.Writer).Write([]byte("{}"))
	}
	sut := &snykScanner{auths: dockerCfg, executor: cmdExec}
	_, actualErr := sut.Scan(context.Background(), "my.registry.com/image:tag")
	assert.NoError(t, actualErr)
	cmdExec.AssertExpectations(t)
}

func Test_SnykScanImageWithNoAuthEntry(t *testing.T) {
	dockerCfg := DockerConfig{
		"another.registry.com": DockerConfigEntry{Username: "someuser", Password: "somepwd"},
	}

	expectedArgs := []string{"container", "test", "--json", "my.registry.com/image:tag"}
	cmdExec := new(mockCommandExec)
	call := cmdExec.On("Execute", mock.Anything, "snyk", expectedArgs, mock.Anything).Return(nil).Times(1)
	call.RunFn = func(a mock.Arguments) {
		a.Get(3).(io.Writer).Write([]byte("{}"))
	}
	sut := &snykScanner{auths: dockerCfg, executor: cmdExec}
	_, actualErr := sut.Scan(context.Background(), "my.registry.com/image:tag")
	assert.NoError(t, actualErr)
	cmdExec.AssertExpectations(t)
}

func Test_SnykScanImageWithInvalidImageStringReturnsError(t *testing.T) {
	dockerCfg := DockerConfig{
		"any.registry.com": DockerConfigEntry{Username: "someuser", Password: "somepwd"},
	}
	cmdExec := new(mockCommandExec)
	cmdExec.On("Execute", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(nil).Times(0)
	sut := &snykScanner{auths: dockerCfg, executor: cmdExec}
	_, actualErr := sut.Scan(context.Background(), "my.registry.com/image:tag")
	assert.Error(t, actualErr)
	cmdExec.AssertExpectations(t)
}

func Test_SnykScanErrorFromExecutorReturned(t *testing.T) {
	dockerCfg := DockerConfig{}
	expectedErr := errors.New("any error")
	cmdExec := new(mockCommandExec)
	cmdExec.On("Execute", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(expectedErr).Times(1)
	sut := &snykScanner{auths: dockerCfg, executor: cmdExec}
	_, actualErr := sut.Scan(context.Background(), "my.registry.com/image:")
	assert.ErrorIs(t, expectedErr, actualErr)
	cmdExec.AssertExpectations(t)
}

func Test_SnykScanStdOutFromExecutorUnmarshalled(t *testing.T) {
	dockerCfg := DockerConfig{}
	expectedResults := ScanResult{
		Docker:          DockerInfo{BaseImage: utils.StringPtr("base")},
		Vulnerabilities: []Vulnerability{{Id: "id1"}},
	}
	cmdExec := new(mockCommandExec)
	call := cmdExec.On("Execute", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(nil).Times(1)
	call.RunFn = func(a mock.Arguments) {
		resultBytes, _ := json.Marshal(&expectedResults)
		a.Get(3).(io.Writer).Write(resultBytes)
	}
	sut := &snykScanner{auths: dockerCfg, executor: cmdExec}
	actualScanResult, actualErr := sut.Scan(context.Background(), "my.registry.com/image:")
	assert.NoError(t, actualErr)
	assert.Equal(t, expectedResults, *actualScanResult)
	cmdExec.AssertExpectations(t)
}
