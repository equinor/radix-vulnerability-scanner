package imageworker

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/equinor/radix-vulnerability-scanner/pkg/dockercfg"
	"github.com/equinor/radix-vulnerability-scanner/pkg/observe"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

type mockQueue struct {
	mock.Mock
}

// AddRateLimited does something
func (m *mockQueue) AddRateLimited(item interface{}) { m.Called(item) }
func (m *mockQueue) Forget(item interface{})         { m.Called(item) }
func (m *mockQueue) NumRequeues(item interface{}) int {
	args := m.Called(item)
	return args.Int(0)
}
func (m *mockQueue) AddAfter(item interface{}, duration time.Duration) { m.Called() }
func (m *mockQueue) Add(item interface{})                              { m.Called(item) }
func (m *mockQueue) Len() int {
	args := m.Called()
	return args.Int(0)
}
func (m *mockQueue) Get() (item interface{}, shutdown bool) {
	args := m.Called()
	return args.Get(0), args.Bool(1)
}
func (m *mockQueue) Done(item interface{}) { m.Called(item) }
func (m *mockQueue) ShutDown()             { m.Called() }
func (m *mockQueue) ShutDownWithDrain()    { m.Called() }
func (m *mockQueue) ShuttingDown() bool {
	args := m.Called()
	return args.Bool(0)
}

type mockHandler struct {
	mock.Mock
}

func (f *mockHandler) Handle(ctx context.Context, image string, dockerConfig dockercfg.Config) error {
	args := f.Called(ctx, image, dockerConfig)
	return args.Error(0)
}

func Test_NewWorker(t *testing.T) {
	h := &mockHandler{}
	sut := New(h)
	assert.Equal(t, h, sut.handler)
	assert.NotNil(t, sut.queue)
	assert.False(t, sut.running)
}

func Test_WorkerStart(t *testing.T) {
	h := &mockHandler{}
	sut := New(h)
	stopCh := make(chan struct{})
	err := sut.Start(1, stopCh)
	require.NoError(t, err)
	assert.True(t, sut.running)
	err = sut.Start(1, stopCh)
	assert.Error(t, err)
	close(stopCh)
	time.Sleep(100 * time.Millisecond) // Sleep to allow go-routine in sut.Start(..) to receive close signal
	assert.False(t, sut.running)
}

func Test_WorkerProcessImageWithSuccess(t *testing.T) {
	stopCh := make(chan struct{})
	imgHandler := &mockHandler{}
	queue := &mockQueue{}
	sut := &Worker{handler: imgHandler, queue: queue}
	err := sut.Start(1, stopCh)
	require.NoError(t, err)
	imageSubject := observe.NewSubject[observe.ImageInfo]()
	imageSubject.AttachObserver(sut)

	// Handle image with no error
	imageInfo := observe.ImageInfo{ImageName: "image:tag", DockerConfig: dockercfg.Config{Auths: dockercfg.AuthMap{"any": {}}}}
	queue.On("Add", &imageInfo).Times(1)
	queue.On("Get").Times(1).Return(&imageInfo, false) // First call to get returns image
	queue.On("Get").Times(1).Return("", true)          // Second call to get (in loop) returns shutdown true
	queue.On("ShuttingDown").Times(1).Return(false)
	queue.On("Done", &imageInfo).Times(1)
	queue.On("Forget", &imageInfo).Times(1)
	imgHandler.On("Handle", mock.Anything, imageInfo.ImageName, imageInfo.DockerConfig).Times(1).Return(nil)
	imageSubject.Next(imageInfo)
	time.Sleep(100 * time.Millisecond) // Sleep to let worker go-routines process the queue

	imgHandler.AssertExpectations(t)
}

func Test_WorkerProcessImageWithError(t *testing.T) {
	stopCh := make(chan struct{})
	imgHandler := &mockHandler{}
	queue := &mockQueue{}
	sut := &Worker{handler: imgHandler, queue: queue}
	err := sut.Start(1, stopCh)
	require.NoError(t, err)
	imageSubject := observe.NewSubject[observe.ImageInfo]()
	imageSubject.AttachObserver(sut)

	// Handle image with no error
	imageInfo := observe.ImageInfo{ImageName: "image:tag"}
	queue.On("Add", &imageInfo).Times(1)
	queue.On("Get").Times(1).Return(&imageInfo, false) // First call to get returns image
	queue.On("Get").Times(1).Return("", true)          // Second call to get (in loop) returns shutdown true
	queue.On("ShuttingDown").Times(1).Return(false)
	queue.On("Done", &imageInfo).Times(1)
	queue.On("NumRequeues", &imageInfo).Times(1).Return(2)
	queue.On("AddRateLimited", &imageInfo).Times(1)
	imgHandler.On("Handle", mock.Anything, imageInfo.ImageName, mock.Anything).Times(1).Return(errors.New("any error"))
	imageSubject.Next(imageInfo)
	time.Sleep(100 * time.Millisecond) // Sleep to let worker go-routines process the queue

	imgHandler.AssertExpectations(t)
}

func Test_WorkerProcessImageWithError_MaxRequeuesExceeded(t *testing.T) {
	stopCh := make(chan struct{})
	imghandler := &mockHandler{}
	queue := &mockQueue{}
	sut := &Worker{handler: imghandler, queue: queue}
	err := sut.Start(1, stopCh)
	require.NoError(t, err)
	imageSubject := observe.NewSubject[observe.ImageInfo]()
	imageSubject.AttachObserver(sut)

	// Handle image with no error
	imageInfo := observe.ImageInfo{ImageName: "image:tag"}
	queue.On("Add", &imageInfo).Times(1)
	queue.On("Get").Times(1).Return(&imageInfo, false) // First call to get returns image
	queue.On("Get").Times(1).Return("", true)          // Second call to get (in loop) returns shutdown true
	queue.On("Done", &imageInfo).Times(1)
	queue.On("ShuttingDown").Times(1).Return(false)
	queue.On("NumRequeues", &imageInfo).Times(1).Return(maxNumberOfRequeues)
	queue.On("Forget", &imageInfo).Times(1)
	imghandler.On("Handle", mock.Anything, imageInfo.ImageName, mock.Anything).Times(1).Return(errors.New("any error"))
	imageSubject.Next(imageInfo)
	time.Sleep(100 * time.Millisecond) // Sleep to let worker go-routines process the queue

	imghandler.AssertExpectations(t)
}
