package imageworker

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/equinor/radix-vulnerability-scanner/pkg/observe"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type mockQueue struct {
	mock.Mock
}

// AddRateLimited does something
func (m *mockQueue) AddRateLimited(item interface{}) { m.Called(item) }
func (m *mockQueue) Forget(item interface{})         { m.Called(item) }
func (m *mockQueue) NumRequeues(item interface{}) int {
	args := m.Called(item)
	return args.Int(0)
}
func (m *mockQueue) AddAfter(item interface{}, duration time.Duration) { m.Called() }
func (m *mockQueue) Add(item interface{})                              { m.Called(item) }
func (m *mockQueue) Len() int {
	args := m.Called()
	return args.Int(0)
}
func (m *mockQueue) Get() (item interface{}, shutdown bool) {
	args := m.Called()
	return args.Get(0), args.Bool(1)
}
func (m *mockQueue) Done(item interface{}) { m.Called(item) }
func (m *mockQueue) ShutDown()             { m.Called() }
func (m *mockQueue) ShutDownWithDrain()    { m.Called() }
func (m *mockQueue) ShuttingDown() bool {
	args := m.Called()
	return args.Bool(0)
}

type mockHandler struct {
	mock.Mock
}

func (f *mockHandler) Handle(ctx context.Context, obj string) error {
	args := f.Called(ctx, obj)
	return args.Error(0)
}

func Test_NewWorker(t *testing.T) {
	h := &mockHandler{}
	sut := New(h)
	assert.Equal(t, h, sut.handler)
	assert.NotNil(t, sut.queue)
	assert.False(t, sut.running)
}

func Test_WorkerStart(t *testing.T) {
	h := &mockHandler{}
	sut := New(h)
	stopCh := make(chan struct{})
	sut.Start(1, stopCh)
	assert.True(t, sut.running)
	err := sut.Start(1, stopCh)
	assert.Error(t, err)
	close(stopCh)
	time.Sleep(100 * time.Millisecond) // Sleep to allow go-routine in sut.Start(..) to receive close signal
	assert.False(t, sut.running)
}

func Test_WorkerProcessImageWithSuccess(t *testing.T) {
	stopCh := make(chan struct{})
	handler := &mockHandler{}
	queue := &mockQueue{}
	sut := &Worker{handler: handler, queue: queue}
	sut.Start(1, stopCh)
	imageSubject := observe.NewSubject[string]()
	imageSubject.AttachObserver(sut)

	// Handle image with no error
	imageName := "image:tag"
	queue.On("Add", imageName).Times(1)
	queue.On("Get").Times(1).Return(imageName, false) // First call to get returns image
	queue.On("Get").Times(1).Return("", true)         // Second call to get (in loop) returns shutdown true
	queue.On("Done", imageName).Times(1)
	queue.On("Forget", imageName).Times(1)
	handler.On("Handle", mock.Anything, imageName).Times(1).Return(nil)
	imageSubject.Next(imageName)
	time.Sleep(100 * time.Millisecond) // Sleep to let worker go-routines process the queue

	handler.AssertExpectations(t)
}

func Test_WorkerProcessImageWithError(t *testing.T) {
	stopCh := make(chan struct{})
	handler := &mockHandler{}
	queue := &mockQueue{}
	sut := &Worker{handler: handler, queue: queue}
	sut.Start(1, stopCh)
	imageSubject := observe.NewSubject[string]()
	imageSubject.AttachObserver(sut)

	// Handle image with no error
	imageName := "image:tag"
	queue.On("Add", imageName).Times(1)
	queue.On("Get").Times(1).Return(imageName, false) // First call to get returns image
	queue.On("Get").Times(1).Return("", true)         // Second call to get (in loop) returns shutdown true
	queue.On("Done", imageName).Times(1)
	queue.On("NumRequeues", imageName).Times(1).Return(2)
	queue.On("AddRateLimited", imageName).Times(1)
	handler.On("Handle", mock.Anything, imageName).Times(1).Return(errors.New("any error"))
	imageSubject.Next(imageName)
	time.Sleep(100 * time.Millisecond) // Sleep to let worker go-routines process the queue

	handler.AssertExpectations(t)
}

func Test_WorkerProcessImageWithError_MaxRequeuesExceeded(t *testing.T) {
	stopCh := make(chan struct{})
	handler := &mockHandler{}
	queue := &mockQueue{}
	sut := &Worker{handler: handler, queue: queue}
	sut.Start(1, stopCh)
	imageSubject := observe.NewSubject[string]()
	imageSubject.AttachObserver(sut)

	// Handle image with no error
	imageName := "image:tag"
	queue.On("Add", imageName).Times(1)
	queue.On("Get").Times(1).Return(imageName, false) // First call to get returns image
	queue.On("Get").Times(1).Return("", true)         // Second call to get (in loop) returns shutdown true
	queue.On("Done", imageName).Times(1)
	queue.On("NumRequeues", imageName).Times(1).Return(maxNumberOfRequeues)
	queue.On("Forget", imageName).Times(1)
	handler.On("Handle", mock.Anything, imageName).Times(1).Return(errors.New("any error"))
	imageSubject.Next(imageName)
	time.Sleep(100 * time.Millisecond) // Sleep to let worker go-routines process the queue

	handler.AssertExpectations(t)
}
