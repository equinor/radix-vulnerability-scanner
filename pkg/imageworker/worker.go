package imageworker

import (
	"context"
	"errors"
	"sync"
	"time"

	"github.com/equinor/radix-vulnerability-scanner/pkg/handler"
	"github.com/equinor/radix-vulnerability-scanner/pkg/observe"
	"github.com/equinor/radix-vulnerability-scanner/pkg/utils"
	"github.com/rs/zerolog/log"
	"k8s.io/client-go/util/workqueue"
)

var maxNumberOfRequeues = 5
var fastRateLimitDelay = 30 * time.Second
var maxFastAttempts = 2
var slowRateLimitDelay = 2 * time.Minute

var _ observe.Observer[observe.ImageInfo] = &Worker{}

type (
	// Worker implements Observer[string] to receive Docker image names from Observables.
	// The received images are added to a queue for processing.
	// Items in the queue is read by one or more worker go-routings when the Worker is started,
	// and the handler.Handle is called with the gived image name
	Worker struct {
		queue     workqueue.RateLimitingInterface
		handler   handler.Handler
		running   bool
		runningMu sync.Mutex
	}
)

// New returns a new Worker
func New(handler handler.Handler) *Worker {
	return &Worker{
		queue:   workqueue.NewRateLimitingQueue(workqueue.NewItemFastSlowRateLimiter(fastRateLimitDelay, slowRateLimitDelay, maxFastAttempts)),
		handler: handler,
	}
}

// Receive implementation of Observer
func (w *Worker) Receive(obj observe.ImageInfo) {
	log.Info().Str("pkg", "imageworker").Str("image", obj.ImageName).Msg("enqueuing image")
	w.queue.Add(&obj)
}

// Start the worker in its own goroutine
func (w *Worker) Start(workers uint, stop <-chan struct{}) error {
	w.runningMu.Lock()
	defer w.runningMu.Unlock()
	if w.running {
		return errors.New("image processor already running")
	}

	w.running = true
	go func() {
		<-stop
		w.running = false
	}()

	for i := uint(0); i < workers; i++ {
		go func(id uint) {
			w.worker(id, stop)
		}(i)
	}

	return nil
}

func (w *Worker) worker(id uint, stop <-chan struct{}) {
	ctx, cancel := utils.ContextForChannel(stop)
	defer cancel()

	for w.processNextItem(ctx) {
	}
}

func (w *Worker) processNextItem(ctx context.Context) bool {
	item, shutdown := w.queue.Get()
	if shutdown || w.queue.ShuttingDown() {
		return false
	}

	w.processItem(ctx, item)

	return true
}

func (w *Worker) processItem(ctx context.Context, item any) {
	defer w.queue.Done(item)

	if image, ok := item.(*observe.ImageInfo); ok {
		log.Info().Str("pkg", "imageworker").Str("image", image.ImageName).Msg("processing image")
		if err := w.handler.Handle(ctx, image.ImageName, image.DockerConfig); err != nil {
			requeues := w.queue.NumRequeues(image)
			if requeues < maxNumberOfRequeues {
				log.Info().Str("pkg", "imageworker").Str("image", image.ImageName).Err(err).Msgf("requeuing scan of image (attempt %d of %d) due to error", requeues+1, maxNumberOfRequeues)
				w.queue.AddRateLimited(item)
				return
			} else {
				w.queue.Forget(item)
				log.Error().Str("pkg", "imageworker").Str("image", image.ImageName).Err(err).Msgf("scan failed for image after %d retries", requeues)
				return
			}
		}
	}

	w.queue.Forget(item)
}
