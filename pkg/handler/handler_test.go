package handler

import (
	"context"
	"errors"
	"fmt"
	"testing"
	"time"

	"github.com/equinor/radix-vulnerability-scanner/pkg/db"
	repomock "github.com/equinor/radix-vulnerability-scanner/pkg/db/mock"
	"github.com/equinor/radix-vulnerability-scanner/pkg/dockercfg"
	"github.com/equinor/radix-vulnerability-scanner/pkg/scan"
	scannermock "github.com/equinor/radix-vulnerability-scanner/pkg/scan/mock"
	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
	"k8s.io/utils/strings/slices"
)

type skewTimeNowMatcher struct {
	skewFrom time.Duration
	skewTo   time.Duration
}

func (e skewTimeNowMatcher) Matches(x interface{}) bool {
	// In case, some value is nil
	t, ok := x.(time.Time)
	if !ok {
		return false
	}
	now := time.Now()
	from := now.Add(e.skewFrom)
	to := now.Add(e.skewTo)

	match := (t.Before(to) || t.Equal(to)) && (t.After(from) || t.Equal(from))
	return match
}

func (e skewTimeNowMatcher) String() string {
	return fmt.Sprintf("is time.Now with skew between %v and %v", e.skewFrom, e.skewTo)
}

type scanTestSuite struct {
	suite.Suite
	repo    *repomock.MockRepository
	scanner *scannermock.MockScanner
}

func (s *scanTestSuite) SetupSuite() {
	ctrl := gomock.NewController(s.T())
	s.repo = repomock.NewMockRepository(ctrl)
	s.scanner = scannermock.NewMockScanner(ctrl)
}

func (s *scanTestSuite) Test_MustNotScanWhenLastScanWithinMaxAge() {
	image := "image:latest"
	s.repo.EXPECT().GetLastImageScan(gomock.Any(), image).Return(&db.ImageScanDto{ScanTime: time.Now()}, nil).Times(1)
	sut := New(s.scanner, s.repo, WithRescanAge(time.Minute))
	err := sut.Handle(context.TODO(), image, "foo", dockercfg.Config{})
	s.Require().NoError(err)
}

func (s *scanTestSuite) Test_MustNotScanWhenGetLastImageScanReturnsError() {
	image := "image:latest"
	expectedErr := errors.New("any error")
	s.repo.EXPECT().GetLastImageScan(gomock.Any(), image).Return(nil, expectedErr).Times(1)
	sut := New(s.scanner, s.repo, WithRescanAge(time.Minute))
	err := sut.Handle(context.TODO(), image, "foo", dockercfg.Config{})
	s.ErrorIs(err, expectedErr)
}

func (s *scanTestSuite) Test_MustScanWhenLastScanExceedMaxAge() {
	scanResult := &scan.ScanResult{}
	s.repo.EXPECT().GetLastImageScan(gomock.Any(), gomock.Any()).Return(&db.ImageScanDto{ScanTime: time.Now().Add(-1 * time.Hour)}, nil).Times(1)
	s.scanner.EXPECT().Scan(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(scanResult, nil).Times(1)
	s.repo.EXPECT().RegisterImageScan(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
	sut := New(s.scanner, s.repo, WithRescanAge(time.Minute))
	err := sut.Handle(context.TODO(), "foo", "bar", dockercfg.Config{})
	s.Require().NoError(err)
}

func (s *scanTestSuite) Test_SuccessfulScanStoresScanResults() {
	image, platform := "image:latest", "anyplatform"
	dockerCfg := dockercfg.Config{Auths: dockercfg.AuthMap{"any": {}}}
	scanResult := &scan.ScanResult{
		Docker: scan.DockerInfo{BaseImage: s.stringPtr("baseimage")},
		Vulnerabilities: []scan.Vulnerability{
			{
				Id: "id1", Title: "title1", PackageName: "pgkname1", Version: "version1", Description: "desc1", Severity: "severity1", CVSS: s.float32Ptr(1), CVSSv3: "cvssv31",
				CreationTime: time.Now(), ModificationTime: time.Now().Add(1 * time.Second), PublicationTime: time.Now().Add(2 * time.Second), DisclosureTime: s.timePtr(time.Now().Add(3 * time.Second)),
				Identifiers: map[string][]string{"CVE": {"CVE1-1", "CVE1-2"}, "CWE": {"CWE1-1", "CWE1-2"}, "ignore": {"ignore1"}},
				References:  []scan.References{{URL: "url1-1"}, {URL: "url1-2"}},
			},
			{
				Id: "id2", Title: "title2", PackageName: "pgkname2", Version: "version2", Description: "desc2", Severity: "severity2", CVSS: s.float32Ptr(2), CVSSv3: "cvssv32",
				CreationTime: time.Now().Add(1 * time.Hour), ModificationTime: time.Now().Add(1 * time.Hour).Add(1 * time.Second), PublicationTime: time.Now().Add(1 * time.Hour).Add(2 * time.Second), DisclosureTime: s.timePtr(time.Now().Add(1 * time.Hour).Add(3 * time.Second)),
				Identifiers: map[string][]string{"CVE": {"CVE2-1", "CVE2-2"}, "CWE": {"CWE2-1", "CWE2-2"}, "ignore": {"ignore2"}},
				References:  []scan.References{{URL: "url2-1"}, {URL: "url2-2"}},
			},
		},
	}

	expectedVulnerabilities := func() []db.VulnerabilityBulkDto {
		var vulns []db.VulnerabilityBulkDto
		for _, vuln := range scanResult.Vulnerabilities {
			vulns = append(vulns, db.VulnerabilityBulkDto{
				ExternalId: vuln.Id, PackageName: vuln.PackageName, Version: vuln.Version, Title: vuln.Title, Description: vuln.Description, Severity: vuln.Severity, CVSS: vuln.CVSS, CVSSv3: vuln.CVSSv3,
				CreationTime: vuln.CreationTime, ModificationTime: vuln.ModificationTime, PublicationTime: vuln.PublicationTime, DisclosureTime: vuln.DisclosureTime,
			})
		}
		return vulns
	}()

	expectedIdentifiers := func() []db.VulnerabilityIdentifierBulkDto {
		var idents []db.VulnerabilityIdentifierBulkDto
		for _, vuln := range scanResult.Vulnerabilities {
			for ik, iv := range vuln.Identifiers {
				if slices.Contains(validIdentifierTypes, ik) {
					for _, i := range iv {
						idents = append(idents, db.VulnerabilityIdentifierBulkDto{ExternalId: vuln.Id, IdentifierType: ik, Identifier: i})
					}
				}
			}
		}
		return idents
	}()

	expectedReferences := func() []db.VulnerabilityReferenceBulkDto {
		var ref []db.VulnerabilityReferenceBulkDto
		for _, vuln := range scanResult.Vulnerabilities {
			for _, r := range vuln.References {
				ref = append(ref, db.VulnerabilityReferenceBulkDto{ExternalId: vuln.Id, Url: r.URL})
			}
		}
		return ref
	}()

	s.repo.EXPECT().GetLastImageScan(gomock.Any(), image).Return(&db.ImageScanDto{ScanTime: time.Now().Add(-1 * time.Hour)}, nil).Times(1)
	s.scanner.EXPECT().Scan(gomock.Any(), image, platform, dockerCfg).Return(scanResult, nil).Times(1)
	s.repo.EXPECT().RegisterImageScan(gomock.Any(), image, scanResult.Docker.BaseImage, skewTimeNowMatcher{skewFrom: -5 * time.Second, skewTo: 5 * time.Second}, true, gomock.InAnyOrder(expectedVulnerabilities), gomock.InAnyOrder(expectedIdentifiers), gomock.InAnyOrder(expectedReferences)).Return(nil).Times(1)
	sut := New(s.scanner, s.repo, WithRescanAge(time.Minute))
	err := sut.Handle(context.TODO(), image, platform, dockerCfg)
	s.Require().NoError(err)
}

func (s *scanTestSuite) Test_FailedScanStoresScanFailed() {
	image := "image:latest"

	s.repo.EXPECT().GetLastImageScan(gomock.Any(), image).Return(&db.ImageScanDto{ScanTime: time.Now().Add(-1 * time.Hour)}, nil).Times(1)
	s.scanner.EXPECT().Scan(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, errors.New("any error")).Times(1)
	s.repo.EXPECT().RegisterImageScan(gomock.Any(), image, gomock.Any(), skewTimeNowMatcher{skewFrom: -5 * time.Second, skewTo: 5 * time.Second}, false, []db.VulnerabilityBulkDto{}, []db.VulnerabilityIdentifierBulkDto{}, []db.VulnerabilityReferenceBulkDto{}).Return(nil).Times(1)
	sut := New(s.scanner, s.repo, WithRescanAge(time.Minute))
	err := sut.Handle(context.TODO(), image, "foo", dockercfg.Config{})
	s.Require().NoError(err)
}

func (s *scanTestSuite) Test_FailingToStoreScanResultsReturnsError() {
	expectedErr := errors.New("any error")
	s.repo.EXPECT().GetLastImageScan(gomock.Any(), gomock.Any()).Return(&db.ImageScanDto{ScanTime: time.Now().Add(-1 * time.Hour)}, nil).Times(1)
	s.scanner.EXPECT().Scan(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, nil).Times(1)
	s.repo.EXPECT().RegisterImageScan(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(expectedErr).Times(1)
	sut := New(s.scanner, s.repo, WithRescanAge(time.Minute))
	err := sut.Handle(context.TODO(), "foo", "bar", dockercfg.Config{})
	s.ErrorIs(err, expectedErr)
}

func (s *scanTestSuite) stringPtr(v string) *string {
	return &v
}

func (s *scanTestSuite) float32Ptr(v float32) *float32 {
	return &v
}

func (s *scanTestSuite) timePtr(v time.Time) *time.Time {
	return &v
}

func Test_ScanTestSuite(t *testing.T) {
	suite.Run(t, new(scanTestSuite))
}

func Test_NewVulnerabilityScanner(t *testing.T) {
	repo := &repomock.MockRepository{}
	scanner := &scannermock.MockScanner{}

	var optionCalled *imageVulnerabilityScanner
	optionFunc := func(s *imageVulnerabilityScanner) { optionCalled = s }
	sut := New(scanner, repo, optionFunc).(*imageVulnerabilityScanner)
	assert.Equal(t, scanner, sut.scanner)
	assert.Equal(t, repo, sut.repository)
	assert.Equal(t, defaultTimeout, sut.scanTimeout)
	assert.Equal(t, defaultRescanAge, sut.rescanAge)
	assert.Equal(t, sut, optionCalled)
}

func Test_WithScanTimeout(t *testing.T) {
	handler := &imageVulnerabilityScanner{}
	timeout := 10 * time.Second
	sut := WithScanTimeout(timeout)
	sut(handler)
	assert.Equal(t, timeout, handler.scanTimeout)
}

func Test_WithRescanAge(t *testing.T) {
	handler := &imageVulnerabilityScanner{}
	timeout := 10 * time.Second
	sut := WithRescanAge(timeout)
	sut(handler)
	assert.Equal(t, timeout, handler.rescanAge)
}
