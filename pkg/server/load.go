package server

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/mitchellh/mapstructure"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
)

var defaultFullSyncCronSpec = "0 0 * * *"

func LoadOptions(args []string) (opts *Options, err error) {
	flagset := newOptionsFlagSet()
	if err = flagset.Parse(args); err != nil {
		return
	}

	v := viper.New()
	v.SetEnvPrefix("RVS")
	v.AutomaticEnv()

	opts = &Options{}
	if err = registerFlags(v, "", flagset, opts); err != nil {
		return
	}

	if err = v.UnmarshalExact(opts, func(dc *mapstructure.DecoderConfig) { dc.TagName = "cfg" }); err != nil {
		return
	}

	return
}

func newOptionsFlagSet() *pflag.FlagSet {
	flagset := pflag.NewFlagSet("options", pflag.ExitOnError)
	flagset.String("full-sync-cron-spec", defaultFullSyncCronSpec, "Cron schedule spec when full sync should run")
	flagset.StringSlice("app-name-exclude-list", nil, "List of app names to exclude from scan")
	flagset.Uint("workers", 1, "Number for image scan workers")
	flagset.AddFlagSet(dbFlagset())
	flagset.AddFlagSet(dockerFlagset())
	flagset.AddFlagSet(kubeFlagset())
	flagset.AddFlagSet(vulnerabilityScanFlagset())
	return flagset
}

func dbFlagset() *pflag.FlagSet {
	flagset := pflag.NewFlagSet("db", pflag.ExitOnError)
	flagset.String("db-server", "", "SQL Server address")
	flagset.String("db-database", "", "SQL Server database name")
	flagset.String("db-username", "", "SQL Server user name")
	flagset.String("db-password", "", "SQL Server password")
	return flagset
}

func dockerFlagset() *pflag.FlagSet {
	flagset := pflag.NewFlagSet("docker", pflag.ExitOnError)
	flagset.String("docker-config-file", "", "Path to Docker config file with auths")
	return flagset
}

func kubeFlagset() *pflag.FlagSet {
	flagset := pflag.NewFlagSet("docker", pflag.ExitOnError)
	flagset.String("kube-config-file", "", "Path to Kubernetes config file for k8s api client")
	return flagset
}

func vulnerabilityScanFlagset() *pflag.FlagSet {
	flagset := pflag.NewFlagSet("vulnerability-scan", pflag.ExitOnError)
	flagset.Duration("vulnerability-scan-timeout", 0, "Image vulnerability scan context timeout")
	flagset.Duration("vulnerability-rescan-age", 0, "Defines the minimum age of the last scan before a new scan is performed")
	return flagset
}

func registerFlags(v *viper.Viper, prefix string, flagSet *pflag.FlagSet, options interface{}) error {
	val := reflect.ValueOf(options)
	var typ reflect.Type
	if val.Kind() == reflect.Ptr {
		typ = val.Elem().Type()
	} else {
		typ = val.Type()
	}

	for i := 0; i < typ.NumField(); i++ {
		// pull out the struct tags:
		//    flag - the name of the command line flag
		//    cfg - the name of the config file option
		field := typ.Field(i)
		fieldV := reflect.Indirect(val).Field(i)
		fieldName := strings.Join([]string{prefix, field.Name}, ".")

		cfgName := field.Tag.Get("cfg")
		if cfgName == ",internal" {
			// Public but internal types that should not be exposed to users, skip them
			continue
		}

		if field.Name == strings.ToLower(field.Name) {
			// Unexported fields cannot be set by a user, so won't have tags or flags, skip them
			continue
		}

		if field.Type.Kind() == reflect.Struct {
			if cfgName != ",squash" {
				return fmt.Errorf("field %q does not have required cfg tag: `,squash`", fieldName)
			}
			err := registerFlags(v, fieldName, flagSet, fieldV.Interface())
			if err != nil {
				return err
			}
			continue
		}

		flagName := field.Tag.Get("flag")
		if flagName == "" || cfgName == "" {
			return fmt.Errorf("field %q does not have required tags (cfg, flag)", fieldName)
		}

		if flagSet == nil {
			return fmt.Errorf("flagset cannot be nil")
		}

		f := flagSet.Lookup(flagName)
		if f == nil {
			return fmt.Errorf("field %q does not have a registered flag", flagName)
		}
		err := v.BindPFlag(cfgName, f)
		if err != nil {
			return fmt.Errorf("error binding flag for field %q: %w", fieldName, err)
		}
	}

	return nil
}
