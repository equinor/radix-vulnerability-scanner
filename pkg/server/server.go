package server

import (
	"sync"

	v1 "github.com/equinor/radix-operator/pkg/apis/radix/v1"
	radix "github.com/equinor/radix-operator/pkg/client/clientset/versioned"
	radixinformer "github.com/equinor/radix-operator/pkg/client/informers/externalversions"
	"github.com/equinor/radix-vulnerability-scanner/pkg/db"
	"github.com/equinor/radix-vulnerability-scanner/pkg/handler"
	"github.com/equinor/radix-vulnerability-scanner/pkg/imageworker"
	"github.com/equinor/radix-vulnerability-scanner/pkg/observe"
	"github.com/equinor/radix-vulnerability-scanner/pkg/options"
	"github.com/equinor/radix-vulnerability-scanner/pkg/scan"
	"github.com/equinor/radix-vulnerability-scanner/pkg/utils"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/client-go/kubernetes"
)

// Server sets up a pipeline of RadixDeployment observables,
// filters the RDs, extracts image names and enqueues them for processing
type Server struct {
	radixClient radix.Interface
	kubeClient  kubernetes.Interface
	handler     handler.Handler
	running     bool
	runningMu   sync.Mutex
	opts        *options.Options
}

// New creates a new Server
func New(kubeClient kubernetes.Interface, radixClient radix.Interface, scanner scan.Scanner, repo db.Repository, opts *options.Options) (*Server, error) {

	imageHandler, err := getImageHandler(scanner, repo, &opts.VulnerabilityScan)
	if err != nil {
		return nil, err
	}

	srv := &Server{
		radixClient: radixClient,
		kubeClient:  kubeClient,
		handler:     imageHandler,
		opts:        opts,
	}
	return srv, nil
}

// Run the server
func (s *Server) Run(stopCh <-chan struct{}) error {
	s.runningMu.Lock()
	defer s.runningMu.Unlock()
	if s.running {
		return nil
	}
	s.running = true
	defer func() {
		s.running = false
	}()
	return s.run(stopCh)
}

func (s *Server) run(stopCh <-chan struct{}) error {
	sharedInformer := radixinformer.NewSharedInformerFactory(s.radixClient, 0)

	// Source subject for add and update events from informer
	rdSubject := observe.NewSubject[*v1.RadixDeployment]()
	eventAdapter := observe.NewSubjectToInformerEventAdapater(rdSubject)
	_, err := sharedInformer.Radix().V1().RadixDeployments().Informer().AddEventHandler(eventAdapter)
	if err != nil {
		return err
	}

	// Observable for scheduled full sync
	rdlister := sharedInformer.Radix().V1().RadixDeployments().Lister()
	ctx, cancel := utils.ContextForChannel(stopCh)
	defer cancel()
	cronObservable, err := observe.NewCron(ctx, s.opts.FullSyncCronSpec, func() []*v1.RadixDeployment {
		if rds, err := rdlister.List(labels.Everything()); err != nil {
			return nil
		} else {
			return rds
		}
	})
	if err != nil {
		return err
	}

	// Receive slice of RD and emit individual RD to observers
	rdListToItem := &observe.RadixDeploymentListMapper{}

	// Receive RD and emit only active RD to observers
	activeDeploymentFilter := observe.ActiveRadixDeploymentFilter()

	// Receive RD and emit RD if appName is not in the exclude list
	excludeAppNamesFilter := observe.ExcludeRadixAppNamesFilter(s.opts.AppNameExcludeList)

	// Received RD and emit image names from components and jobs to observers
	rdToImageMapper := &observe.RadixDeploymentContainerImageMapper{KubeClient: s.kubeClient}

	// worker implements Observer[string] and receives image names for processing
	worker := imageworker.New(s.handler)

	/* Connect observers and observables */
	// rdListToItem receives RD slice from cron
	cronObservable.AttachObserver(rdListToItem)
	defer cronObservable.DetachObserver(rdListToItem)

	// activeDeploymentFilter receives RD from rdListToItem and rdFromInformer
	rdSubject.AttachObserver(activeDeploymentFilter)
	defer rdSubject.DetachObserver(activeDeploymentFilter)
	rdListToItem.AttachObserver(activeDeploymentFilter)
	defer rdListToItem.DetachObserver(activeDeploymentFilter)

	// excludeAppNamesFilter receives RD from activeDeploymentFilter
	activeDeploymentFilter.AttachObserver(excludeAppNamesFilter)
	defer activeDeploymentFilter.DetachObserver(excludeAppNamesFilter)

	// rdToImageMapper receives RD from excludeAppNamesFilter
	excludeAppNamesFilter.AttachObserver(rdToImageMapper)
	defer excludeAppNamesFilter.DetachObserver(rdToImageMapper)

	// worker receives image names from rdToImageMapper
	rdToImageMapper.AttachObserver(worker)
	defer rdToImageMapper.DetachObserver(worker)

	// Start image worker
	err = worker.Start(s.opts.Workers, stopCh)
	if err != nil {
		return err
	}

	// Start informer
	sharedInformer.Start(stopCh)

	// Wait for stopCh to be closed
	<-stopCh
	return nil
}

func getImageHandler(scanner scan.Scanner, repo db.Repository, opts *options.VulnerabilityScanOptions) (handler.Handler, error) {

	var scanOpts []handler.Option

	if opts.ScanTimeout > 0 {
		scanOpts = append(scanOpts, handler.WithScanTimeout(opts.ScanTimeout))
	}

	if opts.RescanAge > 0 {
		scanOpts = append(scanOpts, handler.WithRescanAge(opts.RescanAge))
	}

	return handler.New(scanner, repo, scanOpts...), nil
}
