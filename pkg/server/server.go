package server

import (
	"fmt"
	"sync"

	commongorm "github.com/equinor/radix-common/pkg/gorm"
	v1 "github.com/equinor/radix-operator/pkg/apis/radix/v1"
	radix "github.com/equinor/radix-operator/pkg/client/clientset/versioned"
	radixinformer "github.com/equinor/radix-operator/pkg/client/informers/externalversions"
	"github.com/equinor/radix-vulnerability-scanner/pkg/db"
	"github.com/equinor/radix-vulnerability-scanner/pkg/dockercfg"
	"github.com/equinor/radix-vulnerability-scanner/pkg/handler"
	"github.com/equinor/radix-vulnerability-scanner/pkg/imageworker"
	"github.com/equinor/radix-vulnerability-scanner/pkg/observe"
	"github.com/equinor/radix-vulnerability-scanner/pkg/scan"
	"github.com/equinor/radix-vulnerability-scanner/pkg/utils"
	"github.com/microsoft/go-mssqldb/azuread"
	"gorm.io/driver/sqlserver"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)

// Server sets up a pipeline of RadixDeployment observables,
// filters the RDs, extracts image names and enqueues them for processing
type Server struct {
	radixClient radix.Interface
	kubeClient  kubernetes.Interface
	handler     handler.Handler
	running     bool
	runningMu   sync.Mutex
	opts        *Options
}

// New creates a new Server
func New(opts *Options) (*Server, error) {
	kubeClient, radixClient, err := getKubernetesClients(&opts.Kube)
	if err != nil {
		return nil, err
	}

	imageHandler, err := getImageHandler(opts)
	if err != nil {
		return nil, err
	}

	srv := &Server{
		radixClient: radixClient,
		kubeClient:  kubeClient,
		handler:     imageHandler,
		opts:        opts,
	}
	return srv, nil
}

// Run the server
func (s *Server) Run(stopCh <-chan struct{}) error {
	s.runningMu.Lock()
	defer s.runningMu.Unlock()
	if s.running {
		return nil
	}
	s.running = true
	defer func() {
		s.running = false
	}()
	return s.run(stopCh)
}

func (s *Server) run(stopCh <-chan struct{}) error {
	sharedInformer := radixinformer.NewSharedInformerFactory(s.radixClient, 0)

	// Source subject for add and update events from informer
	rdSubject := observe.NewSubject[*v1.RadixDeployment]()
	eventAdapter := observe.NewSubjectToInformerEventAdapater(rdSubject)
	_, err := sharedInformer.Radix().V1().RadixDeployments().Informer().AddEventHandler(eventAdapter)
	if err != nil {
		return err
	}

	// Observable for scheduled full sync
	rdlister := sharedInformer.Radix().V1().RadixDeployments().Lister()
	ctx, cancel := utils.ContextForChannel(stopCh)
	defer cancel()
	cronObservable, err := observe.NewCron(ctx, s.opts.FullSyncCronSpec, func() []*v1.RadixDeployment {
		if rds, err := rdlister.List(labels.Everything()); err != nil {
			return nil
		} else {
			return rds
		}
	})
	if err != nil {
		return err
	}

	// Receive slice of RD and emit individual RD to observers
	rdListToItem := &observe.RadixDeploymentListMapper{}

	// Receive RD and emit only active RD to observers
	activeDeploymentFilter := observe.ActiveRadixDeploymentFilter()

	// Receive RD and emit RD if appName is not in the exclude list
	excludeAppNamesFilter := observe.ExcludeRadixAppNamesFilter(s.opts.AppNameExcludeList)

	// Received RD and emit image names from components and jobs to observers
	rdToImageMapper := &observe.RadixDeploymentContainerImageMapper{KubeClient: s.kubeClient}

	// worker implements Observer[string] and receives image names for processing
	worker := imageworker.New(s.handler)

	/* Connect observers and observables */
	// rdListToItem receives RD slice from cron
	cronObservable.AttachObserver(rdListToItem)
	defer cronObservable.DetachObserver(rdListToItem)

	// activeDeploymentFilter receives RD from rdListToItem and rdFromInformer
	rdSubject.AttachObserver(activeDeploymentFilter)
	defer rdSubject.DetachObserver(activeDeploymentFilter)
	rdListToItem.AttachObserver(activeDeploymentFilter)
	defer rdListToItem.DetachObserver(activeDeploymentFilter)

	// excludeAppNamesFilter receives RD from activeDeploymentFilter
	activeDeploymentFilter.AttachObserver(excludeAppNamesFilter)
	defer activeDeploymentFilter.DetachObserver(excludeAppNamesFilter)

	// rdToImageMapper receives RD from excludeAppNamesFilter
	excludeAppNamesFilter.AttachObserver(rdToImageMapper)
	defer excludeAppNamesFilter.DetachObserver(rdToImageMapper)

	// worker receives image names from rdToImageMapper
	rdToImageMapper.AttachObserver(worker)
	defer rdToImageMapper.DetachObserver(worker)

	// Start image worker
	err = worker.Start(s.opts.Workers, stopCh)
	if err != nil {
		return err
	}

	// Start informer
	sharedInformer.Start(stopCh)

	// Wait for stopCh to be closed
	<-stopCh
	return nil
}

func getRepository(opts *DBOptions) (db.Repository, error) {
	var dsn string
	if opts.UseFederatedToken {
		dsn = fmt.Sprintf("server=%s;database=%s;fedauth=ActiveDirectoryDefault", opts.Server, opts.Database)
	} else {
		dsn = fmt.Sprintf("server=%s;database=%s;user id=%s;password=%s", opts.Server, opts.Database, opts.UserName, opts.Password)
	}

	dialector := sqlserver.New(sqlserver.Config{
		DriverName: azuread.DriverName,
		DSN:        dsn,
	})

	gormdb, err := gorm.Open(dialector, &gorm.Config{
		NamingStrategy:       schema.NamingStrategy{NoLowerCase: true},
		Logger:               commongorm.NewLogger(),
		DisableAutomaticPing: false,
	})
	if err != nil {
		return nil, err
	}

	return db.NewGormRepository(gormdb), nil
}

func getKubernetesClients(opts *KubeOptions) (kubernetes.Interface, radix.Interface, error) {
	var clientConfig *rest.Config
	var err error

	if len(opts.KubeConfigFile) > 0 {
		loadingRules := &clientcmd.ClientConfigLoadingRules{ExplicitPath: opts.KubeConfigFile}
		loader := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &clientcmd.ConfigOverrides{})
		clientConfig, err = loader.ClientConfig()
	} else {
		clientConfig, err = rest.InClusterConfig()
	}
	if err != nil {
		return nil, nil, err
	}

	kubeClient, err := kubernetes.NewForConfig(clientConfig)
	if err != nil {
		return nil, nil, err
	}

	radixClient, err := radix.NewForConfig(clientConfig)
	if err != nil {
		return nil, nil, err
	}

	return kubeClient, radixClient, nil
}

func getImageHandler(opts *Options) (handler.Handler, error) {
	scanner, err := getImageScanner(&opts.Docker)
	if err != nil {
		return nil, err
	}

	repo, err := getRepository(&opts.DB)
	if err != nil {
		return nil, err
	}

	var scanOpts []handler.Option

	if opts.VulnerabilityScan.ScanTimeout > 0 {
		scanOpts = append(scanOpts, handler.WithScanTimeout(opts.VulnerabilityScan.ScanTimeout))
	}

	if opts.VulnerabilityScan.RescanAge > 0 {
		scanOpts = append(scanOpts, handler.WithRescanAge(opts.VulnerabilityScan.RescanAge))
	}

	return handler.New(scanner, repo, scanOpts...), nil
}

func getImageScanner(opts *DockerOptions) (scan.Scanner, error) {
	var dockerAuth dockercfg.DockerAuthConfig
	var err error

	if opts.AuthsFile != "" {
		dockerAuth, err = dockercfg.ReadDockerAuthConfigFromFile(opts.AuthsFile)
		if err != nil {
			return nil, err
		}
	}

	return scan.NewSnyk(dockerAuth), nil
}
