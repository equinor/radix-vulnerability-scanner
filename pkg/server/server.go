package server

import (
	"fmt"
	"sync"

	v1 "github.com/equinor/radix-operator/pkg/apis/radix/v1"
	radixclient "github.com/equinor/radix-operator/pkg/client/clientset/versioned"
	radixinformer "github.com/equinor/radix-operator/pkg/client/informers/externalversions"
	"github.com/equinor/radix-vulnerability-scanner/pkg/db"
	"github.com/equinor/radix-vulnerability-scanner/pkg/handler"
	"github.com/equinor/radix-vulnerability-scanner/pkg/imageworker"
	"github.com/equinor/radix-vulnerability-scanner/pkg/observe"
	"github.com/equinor/radix-vulnerability-scanner/pkg/scan"
	"github.com/equinor/radix-vulnerability-scanner/pkg/utils"
	"gorm.io/driver/sqlserver"
	"gorm.io/gorm"
	gormlogger "gorm.io/gorm/logger"
	"gorm.io/gorm/schema"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)

type Server struct {
	radixClient radixclient.Interface
	handler     handler.Handler[string]
	running     bool
	runningMu   sync.Mutex
	opts        *Options
}

func New(opts *Options) (*Server, error) {

	radixClient, err := getRadixClient(&opts.Kube)
	if err != nil {
		return nil, err
	}

	imageHandler, err := getImageHandler(opts)
	if err != nil {
		return nil, err
	}

	srv := &Server{
		radixClient: radixClient,
		handler:     imageHandler,
		opts:        opts,
	}
	return srv, nil
}

func (s *Server) Start(stopCh <-chan struct{}) {
	s.runningMu.Lock()
	defer s.runningMu.Unlock()
	if s.running {
		return
	}
	s.running = true
	go s.run(stopCh)
}

func (s *Server) Run(stopCh <-chan struct{}) {
	s.runningMu.Lock()
	defer s.runningMu.Unlock()
	if s.running {
		return
	}
	s.running = true
	defer func() {
		s.running = false
	}()
	s.run(stopCh)
}

func (s *Server) run(stopCh <-chan struct{}) {
	worker := imageworker.New(s.handler)
	worker.Start(1, stopCh)

	// Emit images from RadixDeployment
	rdToImageMapper := &observe.RadixDeploymentContainerImageMapper{}
	rdToImageMapper.AttachObserver(worker)
	defer rdToImageMapper.DetachObserver(worker)

	// Filter on active RadixDeployments
	activeDeploymentFilter := observe.ActiveRadixDeploymentFilter()
	activeDeploymentFilter.AttachObserver(rdToImageMapper)
	defer activeDeploymentFilter.DetachObserver(rdToImageMapper)

	// Create a subject to be used as EventHandler for RadixDeployment informer
	rdSubject := observe.NewSubject[*v1.RadixDeployment]()
	rdSubject.AttachObserver(activeDeploymentFilter)
	defer rdSubject.DetachObserver(activeDeploymentFilter)
	adapter := observe.NewSubjectToInformerEventAdapater(rdSubject)
	sharedInformer := radixinformer.NewSharedInformerFactoryWithOptions(s.radixClient, 0) //radixinformer.WithNamespace("radix-job-demo-qa")
	sharedInformer.Radix().V1().RadixDeployments().Informer().AddEventHandler(adapter)
	sharedInformer.Start(stopCh)

	// Emit RadixDeployments from a list of RadixDeployment
	rdListToItem := &observe.RadixDeploymentListMapper{}
	rdListToItem.AttachObserver(activeDeploymentFilter)
	defer rdListToItem.DetachObserver(activeDeploymentFilter)

	// Emit list of RadixDeployments on a cron schedule
	rdlister := sharedInformer.Radix().V1().RadixDeployments().Lister()
	ctx, cancel := utils.ContextForChannel(stopCh)
	defer cancel()
	cronSubject := observe.NewCron(ctx, s.opts.FullSyncCronSpec, func() []*v1.RadixDeployment {
		if rds, err := rdlister.List(labels.Everything()); err != nil {
			return nil
		} else {
			return rds
		}
	})
	cronSubject.AttachObserver(rdListToItem)
	defer cronSubject.DetachObserver(rdListToItem)

	// Wait for stopCh to be closed
	<-stopCh
}

func getRepository(opts *DBOptions) (db.Repository, error) {
	dsn := fmt.Sprintf("server=%s;database=%s;user id=%s;password=%s", opts.Server, opts.Database, opts.UserName, opts.Password)

	gormdb, err := gorm.Open(sqlserver.Open(dsn), &gorm.Config{
		NamingStrategy:       schema.NamingStrategy{NoLowerCase: true},
		Logger:               gormlogger.Default.LogMode(gormlogger.Silent),
		DisableAutomaticPing: true,
	})
	if err != nil {
		return nil, err
	}

	return db.NewGormRepository(gormdb), nil
}

func getRadixClient(opts *KubeOptions) (radixclient.Interface, error) {
	var clientConfig *rest.Config
	var err error

	if len(opts.KubeConfigFile) > 0 {
		loadingRules := &clientcmd.ClientConfigLoadingRules{ExplicitPath: opts.KubeConfigFile}
		loader := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &clientcmd.ConfigOverrides{})
		clientConfig, err = loader.ClientConfig()
	} else {
		clientConfig, err = rest.InClusterConfig()
	}

	if err != nil {
		return nil, err
	}

	return radixclient.NewForConfig(clientConfig)
}

func getImageHandler(opts *Options) (handler.Handler[string], error) {
	scanner, err := getImageScanner(&opts.Docker)
	if err != nil {
		return nil, err
	}

	repo, err := getRepository(&opts.DB)
	if err != nil {
		return nil, err
	}

	var scanOpts []handler.VulnerabilityScanOption

	if opts.VulnerabilityScan.ScanTimeout > 0 {
		scanOpts = append(scanOpts, handler.WithScanTimeout(opts.VulnerabilityScan.ScanTimeout))
	}

	if opts.VulnerabilityScan.RescanAge > 0 {
		scanOpts = append(scanOpts, handler.WithRescanAge(opts.VulnerabilityScan.RescanAge))
	}

	return handler.NewVulnerabilityScanner(scanner, repo, scanOpts...), nil
}

func getImageScanner(opts *DockerOptions) (scan.Scanner, error) {
	var dockerAuth scan.DockerConfig
	var err error

	if opts.AuthsFile != "" {
		dockerAuth, err = scan.ReadSpecificDockerConfigJSONFile(opts.AuthsFile)
		if err != nil {
			return nil, err
		}
	}

	return scan.NewSnyk(dockerAuth), nil
}
