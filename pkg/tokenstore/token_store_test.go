package tokenstore_test

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"testing"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/equinor/radix-vulnerability-scanner/pkg/tokenstore"
	"github.com/equinor/radix-vulnerability-scanner/pkg/tokenstore/mock"
	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
)

type tokenStoreTestSuite struct {
	suite.Suite
	client *mock.MockFormPoster
	ctrl   *gomock.Controller
}

func (s *tokenStoreTestSuite) SetupSuite() {
	s.ctrl = gomock.NewController(s.T())
	s.client = mock.NewMockFormPoster(s.ctrl)
}

func Test_TokenStoreTestSuite(t *testing.T) {
	suite.Run(t, new(tokenStoreTestSuite))
}

func (s *tokenStoreTestSuite) TestNewTokenStore() {
	credential := fake.TokenCredential{}
	store, err := tokenstore.New(
		context.Background(),
		tokenstore.WithFormPosterOption(s.client),
		tokenstore.WithCredentialOption(&credential),
	)
	require.NoError(s.T(), err)
	assert.Equal(s.T(), &credential, store.Credential)
	assert.Equal(s.T(), s.client, store.Client)
}

func (s *tokenStoreTestSuite) TestGetToken() {
	fakeToken := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyNTkwMjN9.0SDkcr_pdPoY95pDEfzA1sV8RiuY7H69-GUQ9kRdLso"
	s.client.EXPECT().PostForm(
		"https://radix.azurecr.io/oauth2/exchange",
		url.Values{
			"grant_type":   []string{"access_token"},
			"service":      []string{"radix.azurecr.io"},
			"access_token": []string{"fake_token"},
		},
	).Return(&http.Response{
		StatusCode: http.StatusOK,
		Body:       io.NopCloser(bytes.NewBufferString(fmt.Sprintf(`{"refresh_token": "%s"}`, fakeToken))),
	}, nil).Times(1)

	store, err := tokenstore.New(
		context.Background(),
		tokenstore.WithFormPosterOption(s.client),
		tokenstore.WithCredentialOption(&fake.TokenCredential{}),
	)

	token, err := store.Token("radix.azurecr.io")
	require.NoError(s.T(), err)
	assert.Equal(s.T(), fakeToken, token)
}

func (s *tokenStoreTestSuite) TestNonAzureFails() {
	s.client.EXPECT().PostForm(gomock.All(), gomock.Any()).Return(nil, nil).Times(0)

	store, err := tokenstore.New(
		context.Background(),
		tokenstore.WithFormPosterOption(s.client),
		tokenstore.WithCredentialOption(&fake.TokenCredential{}),
	)
	require.NoError(s.T(), err)

	_, err = store.Token("radix.evil-cr.io")
	assert.ErrorIs(s.T(), tokenstore.ErrForbiddenRegistry, err)
}

func (s *tokenStoreTestSuite) TestGetTokenForbidden() {
	s.client.EXPECT().PostForm(
		"https://radix.azurecr.io/oauth2/exchange",
		url.Values{
			"grant_type":   []string{"access_token"},
			"service":      []string{"radix.azurecr.io"},
			"access_token": []string{"fake_token"},
		},
	).Return(&http.Response{
		StatusCode: http.StatusForbidden,
		Body:       io.NopCloser(bytes.NewBufferString(`{"error": "forbidden"}`)),
	}, nil).Times(1)

	store, err := tokenstore.New(
		context.Background(),
		tokenstore.WithFormPosterOption(s.client),
		tokenstore.WithCredentialOption(&fake.TokenCredential{}),
	)
	require.NoError(s.T(), err)

	_, err = store.Token("radix.azurecr.io")
	assert.Error(s.T(), err)
}
