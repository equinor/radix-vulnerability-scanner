package tokensource_test

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"testing"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/equinor/radix-vulnerability-scanner/pkg/tokenstore/tokensource"
	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
)

type AcrTestSuite struct {
	suite.Suite
	ctrl *gomock.Controller
}

func (s *AcrTestSuite) SetupSuite() {
	s.ctrl = gomock.NewController(s.T())
}
func Test_AcrSourceTestSuite(t *testing.T) {
	suite.Run(t, new(AcrTestSuite))
}

// RoundTripFunc is an adapter to implement http.RoundTripper
type RoundTripFunc func(req *http.Request) *http.Response

func (f RoundTripFunc) RoundTrip(req *http.Request) (*http.Response, error) {
	return f(req), nil
}

func (s *AcrTestSuite) TestGetToken() {
	fakeToken := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyNTkwMjN9.0SDkcr_pdPoY95pDEfzA1sV8RiuY7H69-GUQ9kRdLso"
	registryName := "radix.azurecr.io"

	client := &http.Client{
		Transport: RoundTripFunc(func(r *http.Request) *http.Response {
			body, err := io.ReadAll(r.Body)
			s.Require().NoError(err)

			s.Assert().Equal("access_token=fake_token&grant_type=access_token&service=radix.azurecr.io", string(body))

			return &http.Response{
				StatusCode: http.StatusOK,
				Body:       io.NopCloser(bytes.NewBufferString(fmt.Sprintf(`{"refresh_token": "%s"}`, fakeToken))),
				Header:     make(http.Header),
			}
		}),
	}

	source := tokensource.NewACRTokenSource(
		context.Background(), registryName,
		tokensource.WithHttpClient(client),
		tokensource.WithCredentialOption(&fake.TokenCredential{}),
	)

	token, err := source.Token()
	s.Require().NoError(err)
	s.Assert().Equal(fakeToken, token.AccessToken)
}

func (s *AcrTestSuite) TestGetTokenForbidden() {

	client := &http.Client{
		Transport: RoundTripFunc(func(r *http.Request) *http.Response {
			return &http.Response{
				StatusCode: http.StatusForbidden,
				Body:       io.NopCloser(bytes.NewBufferString(`{"error": "forbidden"}`)),
				Header:     make(http.Header),
			}
		}),
	}

	source := tokensource.NewACRTokenSource(
		context.Background(), "radix.azurecr.io",
		tokensource.WithHttpClient(client),
		tokensource.WithCredentialOption(&fake.TokenCredential{}),
	)

	_, err := source.Token()
	assert.Error(s.T(), err)
}

func TestNonAzureFails(t *testing.T) {
	defer func() {
		err := recover().(error)
		assert.ErrorIs(t, err, tokensource.ErrOnlyACRRegistriesAllowed)
	}()

	tokensource.NewACRTokenSource(context.Background(), "radix.evil-cr.io")
}
