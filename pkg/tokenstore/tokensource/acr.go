package tokensource

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"sync"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/golang-jwt/jwt/v5"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"golang.org/x/oauth2"
)

var ErrOnlyACRRegistriesAllowed = errors.New("forbidden registry. only .azurecr.io registries allowed")

type AcrTokenSource struct {
	credential azcore.TokenCredential
	client     *http.Client
	registry   string
	logger     *zerolog.Logger
	ctx        context.Context
	mutex      sync.Mutex
}

type AcrOption func(*AcrTokenSource)

func WithCredentialOption(cred azcore.TokenCredential) AcrOption {
	return func(source *AcrTokenSource) {
		source.credential = cred
	}
}

func WithHttpClient(client *http.Client) AcrOption {
	return func(store *AcrTokenSource) {
		store.client = client
	}
}

func NewACRTokenSource(ctx context.Context, registryName string, options ...AcrOption) oauth2.TokenSource {
	// Make sure we never sends tokens other places than to Azure Container Registry
	if !strings.HasSuffix(registryName, ".azurecr.io") {
		panic(ErrOnlyACRRegistriesAllowed)
	}

	source := &AcrTokenSource{
		registry: registryName,
		logger:   log.Ctx(ctx),
		client:   http.DefaultClient,
		ctx:      ctx,
	}

	for _, option := range options {
		option(source)
	}

	return oauth2.ReuseTokenSource(nil, source)
}

func (s *AcrTokenSource) Token() (*oauth2.Token, error) {
	s.logger.Debug().Str("registry", s.registry).Msg("Fetching new ACR token")
	s.mutex.Lock()
	defer s.mutex.Unlock()

	acrScope := "https://containerregistry.azure.net/.default"
	adToken, err := s.credential.GetToken(s.ctx, policy.TokenRequestOptions{Scopes: []string{acrScope}})
	if err != nil {
		return nil, err
	}

	acrToken, err := s.exchangeAdTokenWithAcrToken(adToken)
	if err != nil {
		return nil, err
	}

	expirationTime, err := getTokenExpiration(acrToken)
	if err != nil {
		return nil, err
	}

	return &oauth2.Token{
		AccessToken:  acrToken,
		TokenType:    "",
		RefreshToken: "",
		Expiry:       expirationTime,
	}, err
}

func (s *AcrTokenSource) exchangeAdTokenWithAcrToken(token azcore.AccessToken) (string, error) {

	formData := url.Values{}
	formData.Set("grant_type", "access_token")
	formData.Set("service", s.registry)
	formData.Set("access_token", token.Token)

	exchangeUrl := fmt.Sprintf("https://%s/oauth2/exchange", s.registry)
	res, err := s.client.PostForm(exchangeUrl, formData)
	if err != nil {
		return "", err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		err = runtime.NewResponseError(res)
		return "", err
	}

	bytes, err := io.ReadAll(res.Body)
	if err != nil {
		return "", err
	}

	var resToken oauth2.Token
	err = json.Unmarshal(bytes, &resToken)

	// ACR Token exchange only returns a refresh token, we will use it as our Access token later on
	return resToken.RefreshToken, err
}

func getTokenExpiration(acrToken string) (time.Time, error) {
	// Will be verified by ACR
	token, _, err := jwt.NewParser().ParseUnverified(acrToken, &jwt.MapClaims{})
	if err != nil {
		return time.Time{}, err
	}

	expirationTime, err := token.Claims.GetExpirationTime()
	if err != nil {
		return time.Time{}, err
	}
	return expirationTime.Time, nil
}
