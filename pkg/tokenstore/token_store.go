package tokenstore

import (
	"context"

	"github.com/containerd/containerd/reference/docker"
	"github.com/equinor/radix-vulnerability-scanner/pkg/registry"
	"github.com/rs/zerolog/log"
	"golang.org/x/oauth2"
)

type TokenStore struct {
	tokens map[string]oauth2.TokenSource
}

type SourceOption func(*TokenStore)

func WithTokenSource(registry string, tokenSource oauth2.TokenSource) SourceOption {
	return func(tokenStore *TokenStore) {
		tokenStore.tokens[registry] = tokenSource
	}
}

type WithSource struct {
	Source   oauth2.TokenSource
	Registry string
}

func New(options ...SourceOption) *TokenStore {
	store := &TokenStore{
		tokens: make(map[string]oauth2.TokenSource),
	}

	for _, option := range options {
		option(store)
	}

	return store
}

func (t *TokenStore) GetAuth(ctx context.Context, image string) (*registry.Auth, error) {
	named, err := docker.ParseDockerRef(image)
	if err != nil {
		return nil, err
	}
	registryName := docker.Domain(named)

	_, ok := t.tokens[registryName]
	if !ok {
		return nil, nil
	}

	token, err := t.tokens[registryName].Token()
	if err != nil {
		return nil, err
	}
	log.Ctx(ctx).Debug().Str("pkg", "tokenstore").Str("registry", registryName).Msg("found auth")
	return &registry.Auth{Username: "00000000-0000-0000-0000-000000000000", Password: token.AccessToken}, nil
}
