package tokenstore

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"sync"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azidentity"
	"github.com/rs/zerolog/log"
	"golang.org/x/oauth2"

	"github.com/golang-jwt/jwt/v5"
)

var (
	ErrForbiddenRegistry = errors.New("forbidden registry")
)

type FormPoster interface {
	PostForm(url string, data url.Values) (*http.Response, error)
}

type TokenStore struct {
	Credential azcore.TokenCredential
	Client     FormPoster

	mutex  sync.Mutex
	tokens map[string]oauth2.TokenSource
	// Ctx    context.Context
}

type Option func(*TokenStore) error

func WithCredentialOption(cred azcore.TokenCredential) Option {
	return func(store *TokenStore) error {
		store.Credential = cred
		return nil
	}
}

func WithFormPosterOption(poster FormPoster) Option {
	return func(store *TokenStore) error {
		store.Client = poster
		return nil
	}
}

func New(options ...Option) (*TokenStore, error) {
	t := &TokenStore{
		Client: http.DefaultClient,

		mutex:  sync.Mutex{},
		tokens: make(map[string]oauth2.TokenSource),

		// Ctx: ctx,
	}

	for _, option := range options {
		err := option(t)
		if err != nil {
			return nil, err
		}
	}

	if t.Credential == nil {
		cred, err := azidentity.NewDefaultAzureCredential(nil)
		if err != nil {
			return nil, err
		}
		t.Credential = cred
	}

	return t, nil
}

func (t *TokenStore) Token(ctx context.Context, registryName string) (string, error) {
	log.Ctx(ctx).Debug().Str("registry", registryName).Msg("Get ACR token")
	t.mutex.Lock()
	defer t.mutex.Unlock()

	_, ok := t.tokens[registryName]
	if !ok {
		if t.tokens == nil {
			t.tokens = make(map[string]oauth2.TokenSource)
		}

		t.tokens[registryName] = oauth2.ReuseTokenSource(nil, t.getACRTokenSource(ctx, registryName))
	}

	token, err := t.tokens[registryName].Token()
	if err != nil {
		return "", err
	}
	return token.AccessToken, nil
}

// TokenSourceFunc is a interface adapter for oauth2.TokenSource
type TokenSourceFunc func() (*oauth2.Token, error)

func (s TokenSourceFunc) Token() (*oauth2.Token, error) {
	return s()
}

func (t *TokenStore) getACRTokenSource(ctx context.Context, registryName string) oauth2.TokenSource {
	return TokenSourceFunc(func() (*oauth2.Token, error) {
		log.Ctx(ctx).Debug().Str("registry", registryName).Msg("Fetching new ACR token")

		acrScope := "https://containerregistry.azure.net/.default"
		adToken, err := t.Credential.GetToken(ctx, policy.TokenRequestOptions{Scopes: []string{acrScope}})
		if err != nil {
			return nil, err
		}

		acrToken, err := t.exchangeAdTokenWithAcrToken(ctx, registryName, adToken)
		if err != nil {
			return nil, err
		}

		expirationTime, err := getTokenExpiration(acrToken)
		if err != nil {
			return nil, err
		}

		return &oauth2.Token{
			AccessToken:  acrToken,
			TokenType:    "",
			RefreshToken: "",
			Expiry:       expirationTime,
		}, err
	})
}

func (t *TokenStore) exchangeAdTokenWithAcrToken(ctx context.Context, registryName string, token azcore.AccessToken) (string, error) {
	// Make sure we never sends tokens other places than to Azure Container Registry
	if !strings.HasSuffix(registryName, ".azurecr.io") {
		log.Ctx(ctx).Error().Str("registry", registryName).Msg("trying to use radix-wi-env helper on a forbidden registry")
		return "", ErrForbiddenRegistry
	}

	formData := url.Values{}
	formData.Set("grant_type", "access_token")
	formData.Set("service", registryName)
	formData.Set("access_token", token.Token)

	exchangeUrl := fmt.Sprintf("https://%s/oauth2/exchange", registryName)
	res, err := t.Client.PostForm(exchangeUrl, formData)
	if err != nil {
		return "", err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		err = runtime.NewResponseError(res)
		return "", err
	}

	bytes, err := io.ReadAll(res.Body)
	if err != nil {
		return "", err
	}

	var resToken oauth2.Token
	err = json.Unmarshal(bytes, &resToken)

	// ACR Token exchange only returns a refresh token, we will use it as our Access token later on
	return resToken.RefreshToken, err
}

func getTokenExpiration(acrToken string) (time.Time, error) {
	// Will be verified by ACR
	token, _, err := jwt.NewParser().ParseUnverified(acrToken, &jwt.MapClaims{})
	if err != nil {
		return time.Time{}, err
	}

	expirationTime, err := token.Claims.GetExpirationTime()
	if err != nil {
		return time.Time{}, err
	}
	return expirationTime.Time, nil
}
