package main

import (
	"context"
	"time"

	"github.com/equinor/radix-vulnerability-scanner/pkg/scan"
	logger "github.com/sirupsen/logrus"
)

var defaultTimeout = 1 * time.Minute

type (
	Handler[T any] interface {
		Handle(ctx context.Context, obj T) error
	}

	vulnerabilityScanner struct {
		scanner    scan.Scanner
		repository ImageVulnerabilityRepository
		timeout    time.Duration
	}
)

func NewVulnerabilityScanAndStoreHandler(scanner scan.Scanner, repository ImageVulnerabilityRepository) Handler[string] {
	return &vulnerabilityScanner{
		scanner:    scanner,
		repository: repository,
		timeout:    defaultTimeout,
	}
}

func (s *vulnerabilityScanner) Handle(ctx context.Context, image string) error {
	// TODO: use https://github.com/go-redsync/redsync for distributed locking
	// As long as we run the scanner as a single pod/replica and with a single worker "thread"
	// we don't need to worry about locking
	// Locking is required if we run multiple workers and/or multiple replicas
	// and we need to ensure that an image is not concurrently processed by two workers/replicas

	timeoutCtx, cancel := context.WithTimeout(ctx, s.timeout)
	defer cancel()

	if mustScan, err := s.shouldScanImage(ctx, image); err != nil {
		return err
	} else if !mustScan {
		logger.Infof("skipping scan of image %s, recently scanned", image)
		return nil
	}

	_, err := s.scanner.Scan(timeoutCtx, image)
	scanSuccess := err == nil

	return s.repository.Store(ctx, &Image{Name: image, LastScanTime: time.Now(), LastScanSuccess: scanSuccess})
}

func (s *vulnerabilityScanner) shouldScanImage(ctx context.Context, image string) (bool, error) {
	scanInfo, err := s.repository.Get(ctx, image)
	if err != nil {
		if _, ok := err.(*NotFound); ok {
			return true, nil
		}
		return false, err
	}

	return time.Since(scanInfo.LastScanTime) > 24*time.Hour, nil
}
