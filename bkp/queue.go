package bkp

import (
	"errors"
	"fmt"
	"reflect"

	"k8s.io/client-go/tools/cache"
)

var ScanQueueClosed = errors.New("scan queue closed")

type ErrRequeueImage struct {
	Err error
}

func (e ErrRequeueImage) Error() string {
	if e.Err == nil {
		return "the processed image should be requeued without returning an error"
	}
	return e.Err.Error()
}

type ProcessNextCallback func(image string) error

type ScanQueue interface {
	ProcessNext(callback ProcessNextCallback) (image string, err error)
}

type InformerScanQueue struct {
	fifo *cache.FIFO
}

type ProcessObjectFromInformerFunc[T any] func(obj T, enqueue func(image string))

func NewInformerScanQueue[T any](informer cache.SharedIndexInformer, processObj ProcessObjectFromInformerFunc[T], stop <-chan struct{}) *InformerScanQueue {

	queue := &InformerScanQueue{
		fifo: cache.NewFIFO(cache.MetaNamespaceKeyFunc),
	}

	informer.AddEventHandler(
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				if objT, ok := obj.(T); ok {
					processObj(objT, queue.enqueue)
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				if objT, ok := newObj.(T); ok {
					processObj(objT, queue.enqueue)
				}
			},
		},
	)

	go func() {
		defer queue.fifo.Close()
		<-stop
	}()

	return queue
}

func (q *InformerScanQueue) enqueue(image string) {
	q.fifo.AddIfNotPresent(cache.ExplicitKey(image))
}

func (q *InformerScanQueue) ProcessNext(processFunc ProcessNextCallback) (string, error) {

	processItem, err := q.fifo.Pop(func(i interface{}) error { return nil })
	switch {
	case err == cache.ErrFIFOClosed:
		return "", ScanQueueClosed
	case err != nil:
		return "", nil
	}

	image, err := q.extractImageFromQueueItem(processItem)
	if err != nil {
		return "", err
	}

	err = processFunc(image)
	if e, ok := err.(ErrRequeueImage); ok {
		fmt.Printf("requeuing failed image %v\n", image)
		q.enqueue(image)
		err = e.Err
	}
	if err != nil {
		return "", err
	}

	return image, err
}

func (q *InformerScanQueue) fifoPopFuncWrapper(processFunc ProcessNextCallback) cache.PopProcessFunc {
	return func(i interface{}) error {
		image, err := q.extractImageFromQueueItem(i)
		if err != nil {
			return err
		}

		return processFunc(image)
	}
}

func (q *InformerScanQueue) extractImageFromQueueItem(item any) (string, error) {
	switch v := item.(type) {
	case cache.ExplicitKey:
		return string(v), nil
	default:
		return "", fmt.Errorf("invalid item type: %v", reflect.TypeOf(item).String())
	}
}
