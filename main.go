package main

import (
	"context"
	"os"
	"os/signal"
	"syscall"

	_ "github.com/denisenkom/go-mssqldb"
	"github.com/spf13/pflag"

	v1 "github.com/equinor/radix-operator/pkg/apis/radix/v1"
	radixclient "github.com/equinor/radix-operator/pkg/client/clientset/versioned"
	radixinformer "github.com/equinor/radix-operator/pkg/client/informers/externalversions"

	"github.com/equinor/radix-vulnerability-scanner/pkg/scan"

	"github.com/sirupsen/logrus"
	logger "github.com/sirupsen/logrus"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)

// "github.com/robfig/cron/v3"

func main() {
	logrus.SetLevel(logger.DebugLevel)

	configFlagsSet := pflag.NewFlagSet("radix-vuln-scanner", pflag.PanicOnError)
	apiToken := configFlagsSet.String("snyk-api-token", "", "Snyk API token to use when scanning images")
	configFlagsSet.Parse(os.Args[1:])

	ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer cancel()

	repo := getRepository()
	snykScanner := scan.NewSnyk()
	if apiToken != nil && *apiToken != "" {
		snykScanner.SetAPIToken(*apiToken)
	}
	worker := NewImageWorker(NewVulnerabilityScanAndStoreHandler(snykScanner, repo))
	worker.Start(1, ctx.Done())

	imageSource := NewImageSubject()

	imageSource.Attach(worker)
	defer imageSource.Detach(worker)

	radixClient, _ := newRadixCient()
	sharedInformer := radixinformer.NewSharedInformerFactoryWithOptions(radixClient, 0) //radixinformer.WithNamespace("radix-job-demo-qa")

	imageSourceAdapter := &ResourceEventHandlerAdapter[*v1.RadixDeployment, string]{Subject: imageSource, AdaptFunc: getImages}
	sharedInformer.Radix().V1().RadixDeployments().Informer().AddEventHandler(imageSourceAdapter)
	sharedInformer.Start(ctx.Done())

	// cronInformer := radixinformer.NewSharedInformerFactoryWithOptions(radixClient, 0)
	// rdlister := cronInformer.Radix().V1().RadixDeployments().Lister()

	// cronInformer.Start(ctx.Done())
	// cronInformer.WaitForCacheSync(ctx.Done())

	// c := cron.New(cron.WithSeconds())
	// c.AddJob("*/10 * * * * *", cron.FuncJob(func() {
	// 	rds, _ := rdlister.List(labels.Everything())
	// 	for _, rd := range rds {
	// 		for image := range getImages(rd) {
	// 			imageSource.Next(image)
	// 		}
	// 	}
	// }))
	// c.Start()
	// defer c.Stop()

	select {
	case <-ctx.Done():
		logger.Info("shutting down")
	}
}

func getRepository() ImageVulnerabilityRepository {
	return &ImageVulnerabilityRepositoryStub{}
}

func getImages(rd *v1.RadixDeployment) <-chan string {
	out := make(chan string)

	go func() {
		defer close(out)
		if rd != nil && rd.Status.Condition == v1.DeploymentActive {
			for _, c := range rd.Spec.Components {
				out <- c.GetImage()
			}

			for _, c := range rd.Spec.Jobs {
				out <- c.GetImage()
			}
		}
	}()

	return out
}

func newRadixCient() (radixclient.Interface, error) {
	kubeConfigPath := os.Getenv("HOME") + "/.kube/config"
	config, err := clientcmd.BuildConfigFromFlags("", kubeConfigPath)

	if err != nil {
		config, err = rest.InClusterConfig()
		if err != nil {
			logger.Fatalf("getClusterConfig InClusterConfig: %v", err)
		}
	}

	return radixclient.NewForConfig(config)
}
