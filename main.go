package main

import (
	"context"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	radix "github.com/equinor/radix-operator/pkg/client/clientset/versioned"
	"github.com/equinor/radix-vulnerability-scanner/pkg/dockercfg"
	"github.com/equinor/radix-vulnerability-scanner/pkg/options"
	"github.com/equinor/radix-vulnerability-scanner/pkg/scan"
	"github.com/equinor/radix-vulnerability-scanner/pkg/tokenstore"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)

func main() {
	ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer cancel()

	opts, err := options.LoadOptions(os.Args[1:])
	if err != nil {
		log.Fatal().Msg(err.Error())
	}

	ctx, err = setupLogger(opts, ctx)
	if err != nil {
		log.Fatal().Msg(err.Error())
	}

	logOptions(opts)

	scanner, err := newSnykScanner(ctx, &opts.Docker)
	if err != nil {
		log.Fatal().Msg(err.Error())
	}

	cfg, _ := dockercfg.ReadDockerAuthConfigFromBytes([]byte(`{"credHelpers": {"radixdev.azurecr.io": "radix-wi-env"}}`))
	_, _ = scanner.Scan(ctx, "radixdev.azurecr.io/edc2023-radix-wi-rihag-web:8onqf", cfg)
	time.Sleep(2 * time.Second)
	_, _ = scanner.Scan(ctx, "radixdev.azurecr.io/edc2023-radix-wi-rihag-web:8onqf", cfg)
	os.Exit(1)

	// repo, err := db.New(&opts.DB)
	// if err != nil {
	// 	log.Fatal().Msg(err.Error())
	// }
	//
	// kubeClient, radixClient, err := getKubernetesClients(&opts.Kube)
	// if err != nil {
	// 	log.Fatal().Msg(err.Error())
	// }
	//
	// srv, err := server.New(kubeClient, radixClient, scanner, repo, opts)
	// if err != nil {
	// 	log.Fatal().Msg(err.Error())
	// }
	//
	// err = srv.Run(ctx.Done())
	// if err != nil {
	// 	log.Fatal().Msg(err.Error())
	// }
}

func setupLogger(opts *options.Options, ctx context.Context) (context.Context, error) {
	zerolog.DurationFieldUnit = time.Millisecond
	level, err := zerolog.ParseLevel(opts.LogLevel)
	if err != nil {
		return nil, err
	}

	zerolog.SetGlobalLevel(level)
	if opts.PrettyPrint {
		log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr, TimeFormat: time.TimeOnly})
	}
	ctx = log.Logger.WithContext(ctx)
	zerolog.DefaultContextLogger = &log.Logger
	return ctx, nil
}

func logOptions(opts *options.Options) {
	log.Info().Msg("Configuration")
	log.Info().Msgf("  full-sync-cron-spec: %v", opts.FullSyncCronSpec)
	log.Info().Msgf("  app-name-exclude-list: %v", strings.Join(opts.AppNameExcludeList, ","))
	log.Info().Msgf("  workers: %v", opts.Workers)
	log.Info().Msgf("  db-server: %v", opts.DB.Server)
	log.Info().Msgf("  db-database: %v", opts.DB.Database)
	log.Info().Msgf("  vulnerability-scan-timeout: %s", opts.VulnerabilityScan.ScanTimeout)
	log.Info().Msgf("  vulnerability-rescan-age: %s", opts.VulnerabilityScan.RescanAge)
	log.Info().Msgf("  docker-config-file: %s", opts.Docker.AuthsFile)
	log.Info().Msgf("  kube-config-file: %s", opts.Kube.KubeConfigFile)
}

func getKubernetesClients(opts *options.KubeOptions) (kubernetes.Interface, radix.Interface, error) {
	var clientConfig *rest.Config
	var err error

	if len(opts.KubeConfigFile) > 0 {
		loadingRules := &clientcmd.ClientConfigLoadingRules{ExplicitPath: opts.KubeConfigFile}
		loader := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &clientcmd.ConfigOverrides{})
		clientConfig, err = loader.ClientConfig()
	} else {
		clientConfig, err = rest.InClusterConfig()
	}
	if err != nil {
		return nil, nil, err
	}

	kubeClient, err := kubernetes.NewForConfig(clientConfig)
	if err != nil {
		return nil, nil, err
	}

	radixClient, err := radix.NewForConfig(clientConfig)
	if err != nil {
		return nil, nil, err
	}

	return kubeClient, radixClient, nil
}

func newSnykScanner(ctx context.Context, opts *options.DockerOptions) (scan.Scanner, error) {
	var dockerConfig dockercfg.DockerConfig
	var err error

	if opts.AuthsFile != "" {
		dockerConfig, err = dockercfg.ReadDockerAuthConfigFromFile(opts.AuthsFile)
		if err != nil {
			return nil, err
		}
	}

	tokenStore, err := tokenstore.NewTokenStore(ctx)
	if err != nil {
		return nil, err
	}

	return scan.NewSnyk(dockerConfig, tokenStore), nil
}
