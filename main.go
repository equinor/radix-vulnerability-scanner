package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"syscall"

	"gorm.io/driver/sqlserver"
	"gorm.io/gorm"
	gormlogger "gorm.io/gorm/logger"
	"gorm.io/gorm/schema"

	v1 "github.com/equinor/radix-operator/pkg/apis/radix/v1"
	radixclient "github.com/equinor/radix-operator/pkg/client/clientset/versioned"
	radixinformer "github.com/equinor/radix-operator/pkg/client/informers/externalversions"

	"github.com/equinor/radix-vulnerability-scanner/pkg/db"
	"github.com/equinor/radix-vulnerability-scanner/pkg/handler"
	"github.com/equinor/radix-vulnerability-scanner/pkg/imageworker"
	"github.com/equinor/radix-vulnerability-scanner/pkg/observe"
	"github.com/equinor/radix-vulnerability-scanner/pkg/options"
	"github.com/equinor/radix-vulnerability-scanner/pkg/scan"

	"github.com/sirupsen/logrus"
	logger "github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)

var defaultEnqueueAllCronSpec = "0 20 * * *"

func main() {
	logrus.SetLevel(logger.DebugLevel)

	opts, err := options.LoadOptions(os.Args[1:])
	if err != nil {
		panic(err)
	}

	ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer cancel()

	repo, err := getRepository(opts.DB)
	if err != nil {
		panic(err)
	}

	dockerAuth, err := loadDockerConfig(opts.Docker)
	if err != nil {
		panic(err)
	}

	snykScanner := scan.NewSnyk(dockerAuth)

	// Worker implements Observer[string] and can attach to subjecs of type string
	// Container images can be added manuallt to the worker by calling OnNext,
	// Or by attaching the worker to a Subject of type string

	worker := imageworker.New(handler.NewVulnerabilityScanner(snykScanner, repo))
	worker.Start(1, ctx.Done())

	// A combined Observable and Observer. Subject takes a RadixDeployment as input, extracts images and notifies registered observer
	rdToImageMapper := &observe.RadixDeploymentContainerImageMapper{}
	rdToImageMapper.AttachObserver(worker)
	defer rdToImageMapper.DetachObserver(worker)

	// Filter on active deployments
	activeDeploymentFilter := observe.ActiveRadixDeploymentFilter()
	activeDeploymentFilter.AttachObserver(rdToImageMapper)
	defer activeDeploymentFilter.DetachObserver(rdToImageMapper)

	rdSubject := observe.NewSubject[*v1.RadixDeployment]()
	rdSubject.AttachObserver(activeDeploymentFilter)
	defer rdSubject.DetachObserver(activeDeploymentFilter)

	// A RadixDeployment Observable that can be used a EventHandler for a SharedIndexInformer
	adapter := observe.NewSubjectToInformerEventAdapater(rdSubject)

	radixClient, err := getRadixClient(opts.Kube)
	if err != nil {
		logger.Fatalf("failed to init radixClient: %v", err)
	}
	sharedInformer := radixinformer.NewSharedInformerFactoryWithOptions(radixClient, 0) //radixinformer.WithNamespace("radix-job-demo-qa")

	sharedInformer.Radix().V1().RadixDeployments().Informer().AddEventHandler(adapter)
	sharedInformer.Start(ctx.Done())

	rdListToItem := &observe.RadixDeploymentListMapper{}
	rdListToItem.AttachObserver(activeDeploymentFilter)
	defer rdListToItem.DetachObserver(activeDeploymentFilter)

	rdlister := sharedInformer.Radix().V1().RadixDeployments().Lister()
	cronSubject := observe.NewCron(ctx, defaultEnqueueAllCronSpec, func() []*v1.RadixDeployment {
		if rds, err := rdlister.List(labels.Everything()); err != nil {
			return nil
		} else {
			return rds
		}
	})
	cronSubject.AttachObserver(rdListToItem)
	defer cronSubject.DetachObserver(rdListToItem)

	<-ctx.Done()
	logger.Info("shutting down")

}

func loadDockerConfig(opts options.DockerOptions) (scan.DockerConfig, error) {
	if opts.AuthsFile != "" {
		return scan.ReadSpecificDockerConfigJSONFile(opts.AuthsFile)
	}

	return nil, nil
}

func getRepository(opts options.DBOptions) (db.Repository, error) {
	dsn := fmt.Sprintf("server=%s;database=%s;user id=%s;password=%s", opts.Server, opts.Database, opts.UserName, opts.Password)

	gormdb, err := gorm.Open(sqlserver.Open(dsn), &gorm.Config{
		NamingStrategy: schema.NamingStrategy{NoLowerCase: true},
		Logger:         gormlogger.Default.LogMode(gormlogger.Silent),
	})
	if err != nil {
		return nil, err
	}

	return db.NewGormRepository(gormdb), nil
}

func getRadixClient(opts options.KubeOptions) (radixclient.Interface, error) {
	var clientConfig *rest.Config
	var err error

	if len(opts.KubeConfigFile) > 0 {
		loadingRules := &clientcmd.ClientConfigLoadingRules{ExplicitPath: opts.KubeConfigFile}
		loader := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &clientcmd.ConfigOverrides{})
		clientConfig, err = loader.ClientConfig()
	} else {
		clientConfig, err = rest.InClusterConfig()
	}

	if err != nil {
		return nil, err
	}

	return radixclient.NewForConfig(clientConfig)
}
