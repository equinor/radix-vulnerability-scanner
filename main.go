package main

import (
	"context"
	"errors"
	"fmt"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"

	v1 "github.com/equinor/radix-operator/pkg/apis/radix/v1"
	radixclient "github.com/equinor/radix-operator/pkg/client/clientset/versioned"
	radixinformer "github.com/equinor/radix-operator/pkg/client/informers/externalversions"
	"github.com/equinor/radix-vulnerability-scanner/pkg/scan"
	"github.com/sirupsen/logrus"
	logger "github.com/sirupsen/logrus"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/workqueue"
)

func main() {
	logrus.SetLevel(logger.DebugLevel)
	rootCtx, cancel := context.WithTimeout(context.Background(), 60*time.Minute)
	defer cancel()
	ctx, cancel := signal.NotifyContext(rootCtx, syscall.SIGINT, syscall.SIGTERM)
	defer cancel()

	snykScanner := scan.Snyk()

	processor := &ImageProcessorImpl{
		Queue:   workqueue.NewRateLimitingQueue(workqueue.NewItemFastSlowRateLimiter(30*time.Second, 10*time.Minute, 2)),
		Handler: &imageVulnerabilityHandler{snykScanner},
	}
	adapter := &ResourceEventHandlerAdapter[*v1.RadixDeployment]{processor, ProcessRadixDeploymentEvent}

	radixClient, _ := newRadixCient()

	sharedInformer := radixinformer.NewSharedInformerFactoryWithOptions(radixClient, 0, radixinformer.WithNamespace("radix-magnus-example-1-dev"))
	sharedInformer.Radix().V1().RadixDeployments().Informer().AddEventHandler(adapter)
	sharedInformer.Start(ctx.Done())

	if err := processor.Start(1, ctx.Done()); err != nil {
		panic(err)
	}

	select {
	case <-rootCtx.Done():
		logger.Info("shutting down")
	}
}

func ProcessRadixDeploymentEvent(rd *v1.RadixDeployment, adder func(image string)) {
	if rd == nil {
		return
	}

	if rd.Status.Condition != v1.DeploymentActive {
		return
	}

	for _, c := range rd.Spec.Components {
		adder(c.GetImage())
	}

	for _, c := range rd.Spec.Jobs {
		adder(c.GetImage())
	}
}

type ResourceEventHandlerAdapter[T any] struct {
	ImageProcessor ImageProcessor
	ProcessItem    func(item T, adder func(image string))
}

func (a *ResourceEventHandlerAdapter[T]) OnAdd(obj any) {
	a.handleEvent(obj)
}
func (a *ResourceEventHandlerAdapter[T]) OnUpdate(oldObj, newObj any) {
	a.handleEvent(newObj)
}
func (a *ResourceEventHandlerAdapter[T]) OnDelete(obj any) {}

func (a *ResourceEventHandlerAdapter[T]) handleEvent(obj any) {
	if a.ProcessItem == nil || a.ImageProcessor == nil {
		return
	}
	if item, ok := obj.(T); ok {
		a.ProcessItem(item, a.ImageProcessor.Add)
	}
}

type ImageHandler interface {
	Handle(ctx context.Context, image string) error
}

var _ ImageHandler = &imageVulnerabilityHandler{}

type imageVulnerabilityHandler struct {
	Scanner scan.Scanner
}

func (v *imageVulnerabilityHandler) Handle(ctx context.Context, image string) error {
	logger.Infof("scanning image %v", image)
	timeoutCtx, cancel := context.WithTimeout(ctx, 2*time.Second)
	defer cancel()
	result, err := v.Scanner.Scan(timeoutCtx, image)
	if err == nil {
		logger.Debugf("found %v vulnerabilities in image %v", len(result.Vulnerabilities), image)
	}

	return err
}

type ImageProcessor interface {
	Add(image string)
	Start(workers uint, stop <-chan struct{}) error
}

type ImageProcessorImpl struct {
	Queue   workqueue.RateLimitingInterface
	Handler ImageHandler
	running bool
	lock    sync.Mutex
}

func (p *ImageProcessorImpl) Add(image string) {
	p.Queue.Add(image)
}

func (p *ImageProcessorImpl) Start(workers uint, stop <-chan struct{}) error {
	p.lock.Lock()
	defer p.lock.Unlock()
	if p.running {
		return errors.New("image processor already running")
	}

	p.running = true
	go func() {
		<-stop
		p.running = false
	}()

	for i := uint(0); i < workers; i++ {
		go func(id uint) {
			p.worker(id, stop)
		}(i)
	}

	return nil
}

func (p *ImageProcessorImpl) worker(id uint, stop <-chan struct{}) {
	ctx, cancel := contextForChannel(stop)
	defer cancel()

	for !p.processNextItem(ctx) {
	}
}

func (p *ImageProcessorImpl) processNextItem(ctx context.Context) (shutdown bool) {
	item, shutdown := p.Queue.Get()
	if shutdown {
		return
	}
	defer p.Queue.Done(item)

	if err := p.Handler.Handle(ctx, fmt.Sprint(item)); err != nil {
		p.Queue.AddRateLimited(item)
		logger.Errorf("error processing %v, requeuing attempt %v", item, p.Queue.NumRequeues(item))
		return
	}

	p.Queue.Forget(item)
	return
}

func newRadixCient() (radixclient.Interface, error) {
	kubeConfigPath := os.Getenv("HOME") + "/.kube/config"
	config, err := clientcmd.BuildConfigFromFlags("", kubeConfigPath)

	if err != nil {
		config, err = rest.InClusterConfig()
		if err != nil {
			logger.Fatalf("getClusterConfig InClusterConfig: %v", err)
		}
	}

	return radixclient.NewForConfig(config)
}

func contextForChannel(parentCh <-chan struct{}) (context.Context, context.CancelFunc) {
	ctx, cancel := context.WithCancel(context.Background())

	go func() {
		select {
		case <-parentCh:
			cancel()
		case <-ctx.Done():
		}
	}()
	return ctx, cancel
}
